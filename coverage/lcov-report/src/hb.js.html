
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for src/hb.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../prettify.css" />
    <link rel="stylesheet" href="../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../index.html">All files</a> / <a href="index.html">src</a> hb.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/410</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/136</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/69</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/2</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">var createHarfBuzz=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >()</span>=&gt;{var _scriptName=<span class="cstat-no" title="statement not covered" >typeof document!="undefined"?document.currentScript?.src:undefined;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >as</span>ync function(moduleArg=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{var moduleRtn;var Module=<span class="cstat-no" title="statement not covered" >moduleArg;</span>var ENVIRONMENT_IS_WEB=<span class="cstat-no" title="statement not covered" >typeof window=="object";</span>var ENVIRONMENT_IS_WORKER=<span class="cstat-no" title="statement not covered" >typeof WorkerGlobalScope!="undefined";</span>var ENVIRONMENT_IS_NODE=<span class="cstat-no" title="statement not covered" >typeof process=="object"&amp;&amp;process.versions?.node&amp;&amp;process.type!="renderer";</span>var arguments_=<span class="cstat-no" title="statement not covered" >[];</span>var thisProgram=<span class="cstat-no" title="statement not covered" >"./this.program";</span>var quit_=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(s</span>tatus,toThrow)=&gt;{<span class="cstat-no" title="statement not covered" >throw toThrow}</span>;<span class="cstat-no" title="statement not covered" ></span>if(typeof __filename!="undefined"){<span class="cstat-no" title="statement not covered" >_scriptName=__filename}</span>else <span class="cstat-no" title="statement not covered" >if(ENVIRONMENT_IS_WORKER){<span class="cstat-no" title="statement not covered" >_scriptName=self.location.href}</span>v</span></span>ar scriptDirectory=<span class="cstat-no" title="statement not covered" >"";</span>function <span class="fstat-no" title="function not covered" >locateFile(</span>path){<span class="cstat-no" title="statement not covered" >if(Module["locateFile"]){<span class="cstat-no" title="statement not covered" >return Module["locateFile"](path,scriptDirectory)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn scriptDirectory+path}</span>var readAsync,readBinary;<span class="cstat-no" title="statement not covered" >if(ENVIRONMENT_IS_NODE){var fs=<span class="cstat-no" title="statement not covered" >require("fs");<span class="cstat-no" title="statement not covered" ></span>scriptDirectory=__dirname+"/";<span class="cstat-no" title="statement not covered" >r</span>eadBinary=<span class="fstat-no" title="function not covered" >fi</span>lename=&gt;{<span class="cstat-no" title="statement not covered" >filename=isFileURI(filename)?new URL(filename):filename;v</span>ar ret=<span class="cstat-no" title="statement not covered" >fs.readFileSync(filename);<span class="cstat-no" title="statement not covered" ></span>return ret}</span>;<span class="cstat-no" title="statement not covered" >r</span>eadAsync=<span class="fstat-no" title="function not covered" >as</span>ync(filename,binary=<span class="branch-0 cbranch-no" title="branch not covered" >true)</span>=&gt;{<span class="cstat-no" title="statement not covered" >filename=isFileURI(filename)?new URL(filename):filename;v</span>ar ret=<span class="cstat-no" title="statement not covered" >fs.readFileSync(filename,binary?undefined:"utf8");<span class="cstat-no" title="statement not covered" ></span>return ret}</span>;<span class="cstat-no" title="statement not covered" >i</span>f(process.argv.length&gt;1){<span class="cstat-no" title="statement not covered" >thisProgram=process.argv[1].replace(/\\/g,"/")}<span class="cstat-no" title="statement not covered" ></span>a</span>rguments_=process.argv.slice(2);<span class="cstat-no" title="statement not covered" >q</span>uit_=<span class="fstat-no" title="function not covered" >(s</span>tatus,toThrow)=&gt;{<span class="cstat-no" title="statement not covered" >process.exitCode=status;<span class="cstat-no" title="statement not covered" >t</span>hrow toThrow}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >scriptDirectory=new URL(".",_scriptName).href}</span>catch{}{<span class="cstat-no" title="statement not covered" ></span>if(ENVIRONMENT_IS_WORKER){<span class="cstat-no" title="statement not covered" >readBinary=<span class="fstat-no" title="function not covered" >ur</span>l=&gt;{var xhr=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest;<span class="cstat-no" title="statement not covered" ></span>xhr.open("GET",url,false);<span class="cstat-no" title="statement not covered" >x</span>hr.responseType="arraybuffer";<span class="cstat-no" title="statement not covered" >x</span>hr.send(null);<span class="cstat-no" title="statement not covered" >r</span>eturn new Uint8Array(xhr.response)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eadAsync=<span class="fstat-no" title="function not covered" >as</span>ync url=&gt;{<span class="cstat-no" title="statement not covered" >if(isFileURI(url)){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >(r</span>esolve,reject)=&gt;{var xhr=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest;<span class="cstat-no" title="statement not covered" ></span>xhr.open("GET",url,true);<span class="cstat-no" title="statement not covered" >x</span>hr.responseType="arraybuffer";<span class="cstat-no" title="statement not covered" >x</span>hr.onload=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(xhr.status==200||xhr.status==0&amp;&amp;xhr.response){<span class="cstat-no" title="statement not covered" >resolve(xhr.response);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>r</span>eject(xhr.status)}</span>;<span class="cstat-no" title="statement not covered" >x</span>hr.onerror=reject;<span class="cstat-no" title="statement not covered" >x</span>hr.send(null)}</span>)}</span>v</span>ar response=<span class="cstat-no" title="statement not covered" >await fetch(url,{credentials:"same-origin"});<span class="cstat-no" title="statement not covered" ></span>if(response.ok){<span class="cstat-no" title="statement not covered" >return response.arrayBuffer()}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new Error(response.status+" : "+response.url)}</span>}</span>}else{}v</span></span>ar out=<span class="cstat-no" title="statement not covered" >console.log.bind(console);</span>var err=<span class="cstat-no" title="statement not covered" >console.error.bind(console);</span>var wasmBinary;var ABORT=<span class="cstat-no" title="statement not covered" >false;</span>var EXITSTATUS;var isFileURI=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fi</span>lename=&gt;<span class="cstat-no" title="statement not covered" >filename.startsWith("file://");</span></span>var readyPromiseResolve,readyPromiseReject;var wasmMemory;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;var HEAP64,HEAPU64;var runtimeInitialized=<span class="cstat-no" title="statement not covered" >false;</span>function <span class="fstat-no" title="function not covered" >updateMemoryViews(</span>){var b=<span class="cstat-no" title="statement not covered" >wasmMemory.buffer;<span class="cstat-no" title="statement not covered" ></span>HEAP8=new Int8Array(b);<span class="cstat-no" title="statement not covered" >H</span>EAP16=new Int16Array(b);<span class="cstat-no" title="statement not covered" >H</span>EAPU8=new Uint8Array(b);<span class="cstat-no" title="statement not covered" >H</span>EAPU16=new Uint16Array(b);<span class="cstat-no" title="statement not covered" >H</span>EAP32=new Int32Array(b);<span class="cstat-no" title="statement not covered" >H</span>EAPU32=new Uint32Array(b);<span class="cstat-no" title="statement not covered" >H</span>EAPF32=new Float32Array(b);<span class="cstat-no" title="statement not covered" >H</span>EAPF64=new Float64Array(b);<span class="cstat-no" title="statement not covered" >H</span>EAP64=new BigInt64Array(b);<span class="cstat-no" title="statement not covered" >H</span>EAPU64=new BigUint64Array(b)}</span>function <span class="fstat-no" title="function not covered" >preRun(</span>){<span class="cstat-no" title="statement not covered" >if(Module["preRun"]){<span class="cstat-no" title="statement not covered" >if(typeof Module["preRun"]=="function")<span class="cstat-no" title="statement not covered" >Module["preRun"]=[Module["preRun"]];<span class="cstat-no" title="statement not covered" >w</span></span>hile(Module["preRun"].length){<span class="cstat-no" title="statement not covered" >addOnPreRun(Module["preRun"].shift())}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>allRuntimeCallbacks(onPreRuns)}</span>function <span class="fstat-no" title="function not covered" >initRuntime(</span>){<span class="cstat-no" title="statement not covered" >runtimeInitialized=true;<span class="cstat-no" title="statement not covered" >w</span>asmExports["__wasm_call_ctors"]()}</span>function <span class="fstat-no" title="function not covered" >postRun(</span>){<span class="cstat-no" title="statement not covered" >if(Module["postRun"]){<span class="cstat-no" title="statement not covered" >if(typeof Module["postRun"]=="function")<span class="cstat-no" title="statement not covered" >Module["postRun"]=[Module["postRun"]];<span class="cstat-no" title="statement not covered" >w</span></span>hile(Module["postRun"].length){<span class="cstat-no" title="statement not covered" >addOnPostRun(Module["postRun"].shift())}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>allRuntimeCallbacks(onPostRuns)}</span>var runDependencies=<span class="cstat-no" title="statement not covered" >0;</span>var dependenciesFulfilled=<span class="cstat-no" title="statement not covered" >null;</span>function <span class="fstat-no" title="function not covered" >addRunDependency(</span>id){<span class="cstat-no" title="statement not covered" >runDependencies++;<span class="cstat-no" title="statement not covered" >M</span>odule["monitorRunDependencies"]?.(runDependencies)}</span>function <span class="fstat-no" title="function not covered" >removeRunDependency(</span>id){<span class="cstat-no" title="statement not covered" >runDependencies--;<span class="cstat-no" title="statement not covered" >M</span>odule["monitorRunDependencies"]?.(runDependencies);<span class="cstat-no" title="statement not covered" >i</span>f(runDependencies==0){<span class="cstat-no" title="statement not covered" >if(dependenciesFulfilled){var callback=<span class="cstat-no" title="statement not covered" >dependenciesFulfilled;<span class="cstat-no" title="statement not covered" ></span>dependenciesFulfilled=null;<span class="cstat-no" title="statement not covered" >c</span>allback()}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >abort(</span>what){<span class="cstat-no" title="statement not covered" >Module["onAbort"]?.(what);<span class="cstat-no" title="statement not covered" >w</span>hat="Aborted("+what+")";<span class="cstat-no" title="statement not covered" >e</span>rr(what);<span class="cstat-no" title="statement not covered" >A</span>BORT=true;<span class="cstat-no" title="statement not covered" >w</span>hat+=". Build with -sASSERTIONS for more info.";v</span>ar e=<span class="cstat-no" title="statement not covered" >new WebAssembly.RuntimeError(what);<span class="cstat-no" title="statement not covered" ></span>readyPromiseReject?.(e);<span class="cstat-no" title="statement not covered" >t</span>hrow e}</span>var wasmBinaryFile;function <span class="fstat-no" title="function not covered" >findWasmBinary(</span>){<span class="cstat-no" title="statement not covered" >return locateFile("hb.wasm")}</span>function <span class="fstat-no" title="function not covered" >getBinarySync(</span>file){<span class="cstat-no" title="statement not covered" >if(file==wasmBinaryFile&amp;&amp;wasmBinary){<span class="cstat-no" title="statement not covered" >return new Uint8Array(wasmBinary)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(readBinary){<span class="cstat-no" title="statement not covered" >return readBinary(file)}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow"both async and sync fetching of the wasm failed"}</span>async function <span class="fstat-no" title="function not covered" >getWasmBinary(</span>binaryFile){<span class="cstat-no" title="statement not covered" >if(!wasmBinary){<span class="cstat-no" title="statement not covered" >try{var response=<span class="cstat-no" title="statement not covered" >await readAsync(binaryFile);<span class="cstat-no" title="statement not covered" ></span>return new Uint8Array(response)}</span>catch{}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn getBinarySync(binaryFile)}</span>async function <span class="fstat-no" title="function not covered" >instantiateArrayBuffer(</span>binaryFile,imports){<span class="cstat-no" title="statement not covered" >try{var binary=<span class="cstat-no" title="statement not covered" >await getWasmBinary(binaryFile);</span>var instance=<span class="cstat-no" title="statement not covered" >await WebAssembly.instantiate(binary,imports);<span class="cstat-no" title="statement not covered" ></span>return instance}</span>catch(reason){<span class="cstat-no" title="statement not covered" >err(`failed to asynchronously prepare wasm: ${reason}`);<span class="cstat-no" title="statement not covered" >a</span>bort(reason)}</span>}</span>async function <span class="fstat-no" title="function not covered" >instantiateAsync(</span>binary,binaryFile,imports){<span class="cstat-no" title="statement not covered" >if(!binary&amp;&amp;typeof WebAssembly.instantiateStreaming=="function"&amp;&amp;!isFileURI(binaryFile)&amp;&amp;!ENVIRONMENT_IS_NODE){<span class="cstat-no" title="statement not covered" >try{var response=<span class="cstat-no" title="statement not covered" >fetch(binaryFile,{credentials:"same-origin"});</span>var instantiationResult=<span class="cstat-no" title="statement not covered" >await WebAssembly.instantiateStreaming(response,imports);<span class="cstat-no" title="statement not covered" ></span>return instantiationResult}</span>catch(reason){<span class="cstat-no" title="statement not covered" >err(`wasm streaming compile failed: ${reason}`);<span class="cstat-no" title="statement not covered" >e</span>rr("falling back to ArrayBuffer instantiation")}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn instantiateArrayBuffer(binaryFile,imports)}</span>function <span class="fstat-no" title="function not covered" >getWasmImports(</span>){<span class="cstat-no" title="statement not covered" >return{env:wasmImports,wasi_snapshot_preview1:wasmImports}}</span>async function <span class="fstat-no" title="function not covered" >createWasm(</span>){function <span class="fstat-no" title="function not covered" >receiveInstance(</span>instance,module){<span class="cstat-no" title="statement not covered" >wasmExports=instance.exports;<span class="cstat-no" title="statement not covered" >M</span>odule["wasmExports"]=wasmExports;<span class="cstat-no" title="statement not covered" >w</span>asmMemory=wasmExports["memory"];<span class="cstat-no" title="statement not covered" >M</span>odule["wasmMemory"]=wasmMemory;<span class="cstat-no" title="statement not covered" >u</span>pdateMemoryViews();<span class="cstat-no" title="statement not covered" >w</span>asmTable=wasmExports["__indirect_function_table"];<span class="cstat-no" title="statement not covered" >a</span>ssignWasmExports(wasmExports);<span class="cstat-no" title="statement not covered" >r</span>emoveRunDependency("wasm-instantiate");<span class="cstat-no" title="statement not covered" >r</span>eturn wasmExports}<span class="cstat-no" title="statement not covered" ></span>addRunDependency("wasm-instantiate");f</span>unction <span class="fstat-no" title="function not covered" >receiveInstantiationResult(</span>result){<span class="cstat-no" title="statement not covered" >return receiveInstance(result["instance"])}</span>var info=<span class="cstat-no" title="statement not covered" >getWasmImports();<span class="cstat-no" title="statement not covered" ></span>if(Module["instantiateWasm"]){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >(r</span>esolve,reject)=&gt;{<span class="cstat-no" title="statement not covered" >Module["instantiateWasm"](info,<span class="fstat-no" title="function not covered" >(m</span>od,inst)=&gt;{<span class="cstat-no" title="statement not covered" >resolve(receiveInstance(mod,inst))}</span>)}</span>)}<span class="cstat-no" title="statement not covered" ></span>w</span>asmBinaryFile??=findWasmBinary();v</span>ar result=<span class="cstat-no" title="statement not covered" >await instantiateAsync(wasmBinary,wasmBinaryFile,info);</span>var exports=<span class="cstat-no" title="statement not covered" >receiveInstantiationResult(result);<span class="cstat-no" title="statement not covered" ></span>return exports}</span>class ExitStatus{name=<span class="cstat-no" title="statement not covered" >"ExitStatus";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(status){<span class="cstat-no" title="statement not covered" >this.message=`Program terminated with exit(${status})`;<span class="cstat-no" title="statement not covered" >t</span>his.status=status}</span>}var callRuntimeCallbacks=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >ca</span>llbacks=&gt;{<span class="cstat-no" title="statement not covered" >while(callbacks.length&gt;0){<span class="cstat-no" title="statement not covered" >callbacks.shift()(Module)}</span>}</span>;</span>var onPostRuns=<span class="cstat-no" title="statement not covered" >[];</span>var addOnPostRun=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >cb</span>=&gt;<span class="cstat-no" title="statement not covered" >onPostRuns.push(cb);</span></span>var onPreRuns=<span class="cstat-no" title="statement not covered" >[];</span>var addOnPreRun=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >cb</span>=&gt;<span class="cstat-no" title="statement not covered" >onPreRuns.push(cb);</span></span>var noExitRuntime=<span class="cstat-no" title="statement not covered" >true;</span>var __abort_js=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >abort("");</span></span>var runtimeKeepaliveCounter=<span class="cstat-no" title="statement not covered" >0;</span>var __emscripten_runtime_keepalive_clear=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >noExitRuntime=false;<span class="cstat-no" title="statement not covered" >r</span>untimeKeepaliveCounter=0}</span>;</span>var timers=<span class="cstat-no" title="statement not covered" >{};</span>var handleException=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(e instanceof ExitStatus||e=="unwind"){<span class="cstat-no" title="statement not covered" >return EXITSTATUS}<span class="cstat-no" title="statement not covered" ></span>q</span>uit_(1,e)}</span>;</span>var keepRuntimeAlive=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >noExitRuntime||runtimeKeepaliveCounter&gt;0;</span></span>var _proc_exit=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >co</span>de=&gt;{<span class="cstat-no" title="statement not covered" >EXITSTATUS=code;<span class="cstat-no" title="statement not covered" >i</span>f(!keepRuntimeAlive()){<span class="cstat-no" title="statement not covered" >Module["onExit"]?.(code);<span class="cstat-no" title="statement not covered" >A</span>BORT=true}<span class="cstat-no" title="statement not covered" ></span>q</span>uit_(code,new ExitStatus(code))}</span>;</span>var exitJS=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(s</span>tatus,implicit)=&gt;{<span class="cstat-no" title="statement not covered" >EXITSTATUS=status;<span class="cstat-no" title="statement not covered" >_</span>proc_exit(status)}</span>;</span>var _exit=<span class="cstat-no" title="statement not covered" >exitJS;</span>var maybeExit=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!keepRuntimeAlive()){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >_exit(EXITSTATUS)}</span>catch(e){<span class="cstat-no" title="statement not covered" >handleException(e)}</span>}</span>}</span>;</span>var callUserCallback=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nc=&gt;{<span class="cstat-no" title="statement not covered" >if(ABORT){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>t</span>ry{<span class="cstat-no" title="statement not covered" >func();<span class="cstat-no" title="statement not covered" >m</span>aybeExit()}</span>catch(e){<span class="cstat-no" title="statement not covered" >handleException(e)}</span>}</span>;</span>var _emscripten_get_now=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >performance.now();</span></span>var __setitimer_js=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(w</span>hich,timeout_ms)=&gt;{<span class="cstat-no" title="statement not covered" >if(timers[which]){<span class="cstat-no" title="statement not covered" >clearTimeout(timers[which].id);<span class="cstat-no" title="statement not covered" >d</span>elete timers[which]}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!timeout_ms)<span class="cstat-no" title="statement not covered" >return 0;v</span></span>ar id=<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >delete timers[which];<span class="cstat-no" title="statement not covered" >c</span>allUserCallback(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >__emscripten_timeout(which,_emscripten_get_now()))</span>}</span>,timeout_ms);<span class="cstat-no" title="statement not covered" ></span>timers[which]={id,timeout_ms};<span class="cstat-no" title="statement not covered" >r</span>eturn 0}</span>;</span>var getHeapMax=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >2147483648;</span></span>var alignMemory=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(s</span>ize,alignment)=&gt;<span class="cstat-no" title="statement not covered" >Math.ceil(size/alignment)*alignment;</span></span>var growMemory=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >si</span>ze=&gt;{var oldHeapSize=<span class="cstat-no" title="statement not covered" >wasmMemory.buffer.byteLength;</span>var pages=<span class="cstat-no" title="statement not covered" >(size-oldHeapSize+65535)/65536|0;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >wasmMemory.grow(pages);<span class="cstat-no" title="statement not covered" >u</span>pdateMemoryViews();<span class="cstat-no" title="statement not covered" >r</span>eturn 1}</span>catch(e){}}</span>;</span>var _emscripten_resize_heap=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >re</span>questedSize=&gt;{var oldSize=<span class="cstat-no" title="statement not covered" >HEAPU8.length;<span class="cstat-no" title="statement not covered" ></span>requestedSize&gt;&gt;&gt;=0;v</span>ar maxHeapSize=<span class="cstat-no" title="statement not covered" >getHeapMax();<span class="cstat-no" title="statement not covered" ></span>if(requestedSize&gt;maxHeapSize){<span class="cstat-no" title="statement not covered" >return false}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var cutDown=<span class="cstat-no" title="statement not covered" >1;</span>cutDown&lt;=4;cutDown*=2){var overGrownHeapSize=<span class="cstat-no" title="statement not covered" >oldSize*(1+.2/cutDown);<span class="cstat-no" title="statement not covered" ></span>overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);v</span>ar newSize=<span class="cstat-no" title="statement not covered" >Math.min(maxHeapSize,alignMemory(Math.max(requestedSize,overGrownHeapSize),65536));</span>var replacement=<span class="cstat-no" title="statement not covered" >growMemory(newSize);<span class="cstat-no" title="statement not covered" ></span>if(replacement){<span class="cstat-no" title="statement not covered" >return true}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false}</span>;</span>var uleb128EncodeWithLen=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >ar</span>r=&gt;{const n=<span class="cstat-no" title="statement not covered" >arr.length;<span class="cstat-no" title="statement not covered" ></span>return[n%128|128,n&gt;&gt;7,...arr]}</span>;</span>var wasmTypeCodes=<span class="cstat-no" title="statement not covered" >{i:127,p:127,j:126,f:125,d:124,e:111};</span>var generateTypePack=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >ty</span>pes=&gt;<span class="cstat-no" title="statement not covered" >uleb128EncodeWithLen(Array.from(types,<span class="fstat-no" title="function not covered" >ty</span>pe=&gt;{var code=<span class="cstat-no" title="statement not covered" >wasmTypeCodes[type];<span class="cstat-no" title="statement not covered" ></span>return code}</span>));</span></span>var convertJsFunctionToWasm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(f</span>unc,sig)=&gt;{var bytes=<span class="cstat-no" title="statement not covered" >Uint8Array.of(0,97,115,109,1,0,0,0,1,...uleb128EncodeWithLen([1,96,...generateTypePack(sig.slice(1)),...generateTypePack(sig[0]==="v"?"":sig[0])]),2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0);</span>var module=<span class="cstat-no" title="statement not covered" >new WebAssembly.Module(bytes);</span>var instance=<span class="cstat-no" title="statement not covered" >new WebAssembly.Instance(module,{e:{f:func}});</span>var wrappedFunc=<span class="cstat-no" title="statement not covered" >instance.exports["f"];<span class="cstat-no" title="statement not covered" ></span>return wrappedFunc}</span>;</span>var wasmTable;var getWasmTableEntry=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>ncPtr=&gt;<span class="cstat-no" title="statement not covered" >wasmTable.get(funcPtr);</span></span>var updateTableMap=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(o</span>ffset,count)=&gt;{<span class="cstat-no" title="statement not covered" >if(functionsInTableMap){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >offset;</span>i&lt;offset+count;i++){var item=<span class="cstat-no" title="statement not covered" >getWasmTableEntry(i);<span class="cstat-no" title="statement not covered" ></span>if(item){<span class="cstat-no" title="statement not covered" >functionsInTableMap.set(item,i)}</span>}</span>}</span>}</span>;</span>var functionsInTableMap;var getFunctionAddress=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nc=&gt;{<span class="cstat-no" title="statement not covered" >if(!functionsInTableMap){<span class="cstat-no" title="statement not covered" >functionsInTableMap=new WeakMap;<span class="cstat-no" title="statement not covered" >u</span>pdateTableMap(0,wasmTable.length)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn functionsInTableMap.get(func)||0}</span>;</span>var freeTableIndexes=<span class="cstat-no" title="statement not covered" >[];</span>var getEmptyTableSlot=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(freeTableIndexes.length){<span class="cstat-no" title="statement not covered" >return freeTableIndexes.pop()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn wasmTable["grow"](1)}</span>;</span>var setWasmTableEntry=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>dx,func)=&gt;<span class="cstat-no" title="statement not covered" >wasmTable.set(idx,func);</span></span>var addFunction=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(f</span>unc,sig)=&gt;{var rtn=<span class="cstat-no" title="statement not covered" >getFunctionAddress(func);<span class="cstat-no" title="statement not covered" ></span>if(rtn){<span class="cstat-no" title="statement not covered" >return rtn}</span>v</span>ar ret=<span class="cstat-no" title="statement not covered" >getEmptyTableSlot();<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >setWasmTableEntry(ret,func)}</span>catch(err){<span class="cstat-no" title="statement not covered" >if(!(err instanceof TypeError)){<span class="cstat-no" title="statement not covered" >throw err}</span>v</span>ar wrapped=<span class="cstat-no" title="statement not covered" >convertJsFunctionToWasm(func,sig);<span class="cstat-no" title="statement not covered" ></span>setWasmTableEntry(ret,wrapped)}<span class="cstat-no" title="statement not covered" ></span>f</span>unctionsInTableMap.set(func,ret);<span class="cstat-no" title="statement not covered" >r</span>eturn ret}</span>;</span>var removeFunction=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >in</span>dex=&gt;{<span class="cstat-no" title="statement not covered" >functionsInTableMap.delete(getWasmTableEntry(index));<span class="cstat-no" title="statement not covered" >s</span>etWasmTableEntry(index,null);<span class="cstat-no" title="statement not covered" >f</span>reeTableIndexes.push(index)}</span>;</span>{<span class="cstat-no" title="statement not covered" >if(Module["noExitRuntime"])<span class="cstat-no" title="statement not covered" >noExitRuntime=Module["noExitRuntime"];<span class="cstat-no" title="statement not covered" >i</span></span>f(Module["print"])<span class="cstat-no" title="statement not covered" >out=Module["print"];<span class="cstat-no" title="statement not covered" >i</span></span>f(Module["printErr"])<span class="cstat-no" title="statement not covered" >err=Module["printErr"];<span class="cstat-no" title="statement not covered" >i</span></span>f(Module["wasmBinary"])<span class="cstat-no" title="statement not covered" >wasmBinary=Module["wasmBinary"];<span class="cstat-no" title="statement not covered" >i</span></span>f(Module["arguments"])<span class="cstat-no" title="statement not covered" >arguments_=Module["arguments"];<span class="cstat-no" title="statement not covered" >i</span></span>f(Module["thisProgram"])<span class="cstat-no" title="statement not covered" >thisProgram=Module["thisProgram"]}<span class="cstat-no" title="statement not covered" ></span></span>Module["wasmMemory"]=wasmMemory;<span class="cstat-no" title="statement not covered" >M</span>odule["wasmExports"]=wasmExports;<span class="cstat-no" title="statement not covered" >M</span>odule["addFunction"]=addFunction;<span class="cstat-no" title="statement not covered" >M</span>odule["removeFunction"]=removeFunction;v</span>ar _hb_blob_create,_hb_blob_destroy,_hb_blob_get_length,_hb_blob_get_data,_hb_buffer_serialize_glyphs,_hb_buffer_create,_hb_buffer_destroy,_hb_buffer_get_content_type,_hb_buffer_set_direction,_hb_buffer_set_script,_hb_buffer_set_language,_hb_buffer_set_flags,_hb_buffer_set_cluster_level,_hb_buffer_get_length,_hb_buffer_get_glyph_infos,_hb_buffer_get_glyph_positions,_hb_glyph_info_get_glyph_flags,_hb_buffer_guess_segment_properties,_hb_buffer_add_utf8,_hb_buffer_add_utf16,_hb_buffer_set_message_func,_hb_language_from_string,_hb_script_from_string,_hb_version,_hb_version_string,_hb_feature_from_string,_malloc,_free,_hb_draw_funcs_set_move_to_func,_hb_draw_funcs_set_line_to_func,_hb_draw_funcs_set_quadratic_to_func,_hb_draw_funcs_set_cubic_to_func,_hb_draw_funcs_set_close_path_func,_hb_draw_funcs_create,_hb_draw_funcs_destroy,_hb_face_create,_hb_face_destroy,_hb_face_reference_table,_hb_face_get_upem,_hb_face_collect_unicodes,_hb_font_draw_glyph,_hb_font_glyph_to_string,_hb_font_create,_hb_font_set_variations,_hb_font_destroy,_hb_font_set_scale,_hb_set_create,_hb_set_destroy,_hb_ot_var_get_axis_infos,_hb_set_get_population,_hb_set_next_many,_hb_shape,__emscripten_timeout;function <span class="fstat-no" title="function not covered" >assignWasmExports(</span>wasmExports){<span class="cstat-no" title="statement not covered" >Module["_hb_blob_create"]=_hb_blob_create=wasmExports["hb_blob_create"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_blob_destroy"]=_hb_blob_destroy=wasmExports["hb_blob_destroy"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_blob_get_length"]=_hb_blob_get_length=wasmExports["hb_blob_get_length"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_blob_get_data"]=_hb_blob_get_data=wasmExports["hb_blob_get_data"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_serialize_glyphs"]=_hb_buffer_serialize_glyphs=wasmExports["hb_buffer_serialize_glyphs"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_create"]=_hb_buffer_create=wasmExports["hb_buffer_create"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_destroy"]=_hb_buffer_destroy=wasmExports["hb_buffer_destroy"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_get_content_type"]=_hb_buffer_get_content_type=wasmExports["hb_buffer_get_content_type"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_set_direction"]=_hb_buffer_set_direction=wasmExports["hb_buffer_set_direction"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_set_script"]=_hb_buffer_set_script=wasmExports["hb_buffer_set_script"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_set_language"]=_hb_buffer_set_language=wasmExports["hb_buffer_set_language"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_set_flags"]=_hb_buffer_set_flags=wasmExports["hb_buffer_set_flags"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_set_cluster_level"]=_hb_buffer_set_cluster_level=wasmExports["hb_buffer_set_cluster_level"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_get_length"]=_hb_buffer_get_length=wasmExports["hb_buffer_get_length"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_get_glyph_infos"]=_hb_buffer_get_glyph_infos=wasmExports["hb_buffer_get_glyph_infos"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_get_glyph_positions"]=_hb_buffer_get_glyph_positions=wasmExports["hb_buffer_get_glyph_positions"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_glyph_info_get_glyph_flags"]=_hb_glyph_info_get_glyph_flags=wasmExports["hb_glyph_info_get_glyph_flags"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_guess_segment_properties"]=_hb_buffer_guess_segment_properties=wasmExports["hb_buffer_guess_segment_properties"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_add_utf8"]=_hb_buffer_add_utf8=wasmExports["hb_buffer_add_utf8"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_add_utf16"]=_hb_buffer_add_utf16=wasmExports["hb_buffer_add_utf16"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_buffer_set_message_func"]=_hb_buffer_set_message_func=wasmExports["hb_buffer_set_message_func"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_language_from_string"]=_hb_language_from_string=wasmExports["hb_language_from_string"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_script_from_string"]=_hb_script_from_string=wasmExports["hb_script_from_string"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_version"]=_hb_version=wasmExports["hb_version"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_version_string"]=_hb_version_string=wasmExports["hb_version_string"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_feature_from_string"]=_hb_feature_from_string=wasmExports["hb_feature_from_string"];<span class="cstat-no" title="statement not covered" >M</span>odule["_malloc"]=_malloc=wasmExports["malloc"];<span class="cstat-no" title="statement not covered" >M</span>odule["_free"]=_free=wasmExports["free"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_draw_funcs_set_move_to_func"]=_hb_draw_funcs_set_move_to_func=wasmExports["hb_draw_funcs_set_move_to_func"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_draw_funcs_set_line_to_func"]=_hb_draw_funcs_set_line_to_func=wasmExports["hb_draw_funcs_set_line_to_func"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_draw_funcs_set_quadratic_to_func"]=_hb_draw_funcs_set_quadratic_to_func=wasmExports["hb_draw_funcs_set_quadratic_to_func"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_draw_funcs_set_cubic_to_func"]=_hb_draw_funcs_set_cubic_to_func=wasmExports["hb_draw_funcs_set_cubic_to_func"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_draw_funcs_set_close_path_func"]=_hb_draw_funcs_set_close_path_func=wasmExports["hb_draw_funcs_set_close_path_func"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_draw_funcs_create"]=_hb_draw_funcs_create=wasmExports["hb_draw_funcs_create"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_draw_funcs_destroy"]=_hb_draw_funcs_destroy=wasmExports["hb_draw_funcs_destroy"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_face_create"]=_hb_face_create=wasmExports["hb_face_create"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_face_destroy"]=_hb_face_destroy=wasmExports["hb_face_destroy"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_face_reference_table"]=_hb_face_reference_table=wasmExports["hb_face_reference_table"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_face_get_upem"]=_hb_face_get_upem=wasmExports["hb_face_get_upem"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_face_collect_unicodes"]=_hb_face_collect_unicodes=wasmExports["hb_face_collect_unicodes"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_font_draw_glyph"]=_hb_font_draw_glyph=wasmExports["hb_font_draw_glyph"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_font_glyph_to_string"]=_hb_font_glyph_to_string=wasmExports["hb_font_glyph_to_string"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_font_create"]=_hb_font_create=wasmExports["hb_font_create"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_font_set_variations"]=_hb_font_set_variations=wasmExports["hb_font_set_variations"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_font_destroy"]=_hb_font_destroy=wasmExports["hb_font_destroy"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_font_set_scale"]=_hb_font_set_scale=wasmExports["hb_font_set_scale"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_set_create"]=_hb_set_create=wasmExports["hb_set_create"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_set_destroy"]=_hb_set_destroy=wasmExports["hb_set_destroy"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_ot_var_get_axis_infos"]=_hb_ot_var_get_axis_infos=wasmExports["hb_ot_var_get_axis_infos"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_set_get_population"]=_hb_set_get_population=wasmExports["hb_set_get_population"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_set_next_many"]=_hb_set_next_many=wasmExports["hb_set_next_many"];<span class="cstat-no" title="statement not covered" >M</span>odule["_hb_shape"]=_hb_shape=wasmExports["hb_shape"];<span class="cstat-no" title="statement not covered" >_</span>_emscripten_timeout=wasmExports["_emscripten_timeout"]}</span>var wasmImports=<span class="cstat-no" title="statement not covered" >{_abort_js:__abort_js,_emscripten_runtime_keepalive_clear:__emscripten_runtime_keepalive_clear,_setitimer_js:__setitimer_js,emscripten_resize_heap:_emscripten_resize_heap,proc_exit:_proc_exit};</span>var wasmExports=<span class="cstat-no" title="statement not covered" >await createWasm();</span>function <span class="fstat-no" title="function not covered" >run(</span>){<span class="cstat-no" title="statement not covered" >if(runDependencies&gt;0){<span class="cstat-no" title="statement not covered" >dependenciesFulfilled=run;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>p</span>reRun();<span class="cstat-no" title="statement not covered" >i</span>f(runDependencies&gt;0){<span class="cstat-no" title="statement not covered" >dependenciesFulfilled=run;<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>f</span>unction <span class="fstat-no" title="function not covered" >doRun(</span>){<span class="cstat-no" title="statement not covered" >Module["calledRun"]=true;<span class="cstat-no" title="statement not covered" >i</span>f(ABORT)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>nitRuntime();<span class="cstat-no" title="statement not covered" >r</span>eadyPromiseResolve?.(Module);<span class="cstat-no" title="statement not covered" >M</span>odule["onRuntimeInitialized"]?.();<span class="cstat-no" title="statement not covered" >p</span>ostRun()}<span class="cstat-no" title="statement not covered" ></span>if(Module["setStatus"]){<span class="cstat-no" title="statement not covered" >Module["setStatus"]("Running...");<span class="cstat-no" title="statement not covered" >s</span>etTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Module["setStatus"](""),</span>1);<span class="cstat-no" title="statement not covered" >d</span>oRun()}</span>,1)}</span>else{<span class="cstat-no" title="statement not covered" >doRun()}</span>}</span>function <span class="fstat-no" title="function not covered" >preInit(</span>){<span class="cstat-no" title="statement not covered" >if(Module["preInit"]){<span class="cstat-no" title="statement not covered" >if(typeof Module["preInit"]=="function")<span class="cstat-no" title="statement not covered" >Module["preInit"]=[Module["preInit"]];<span class="cstat-no" title="statement not covered" >w</span></span>hile(Module["preInit"].length&gt;0){<span class="cstat-no" title="statement not covered" >Module["preInit"].shift()()}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>preInit();<span class="cstat-no" title="statement not covered" >r</span>un();<span class="cstat-no" title="statement not covered" >i</span>f(runtimeInitialized){<span class="cstat-no" title="statement not covered" >moduleRtn=Module}</span>else{<span class="cstat-no" title="statement not covered" >moduleRtn=new Promise(<span class="fstat-no" title="function not covered" >(r</span>esolve,reject)=&gt;{<span class="cstat-no" title="statement not covered" >readyPromiseResolve=resolve;<span class="cstat-no" title="statement not covered" >r</span>eadyPromiseReject=reject}</span>)}</span></span></span></span>
;<span class="cstat-no" title="statement not covered" >return moduleRtn}</span>})();<span class="cstat-no" title="statement not covered" >if(typeof exports==="object"&amp;&amp;typeof module==="object"){<span class="cstat-no" title="statement not covered" >module.exports=createHarfBuzz;<span class="cstat-no" title="statement not covered" >m</span>odule.exports.default=createHarfBuzz}</span>else <span class="cstat-no" title="statement not covered" >if(typeof define==="function"&amp;&amp;define["amd"])<span class="cstat-no" title="statement not covered" >define([],<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >createHarfBuzz)</span>;</span></span></span>
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-09-20T17:25:05.591Z
            </div>
        <script src="../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../sorter.js"></script>
        <script src="../block-navigation.js"></script>
    </body>
</html>
    