// Modern Content Script - Translation Extension Main Script
// Handles DOM scanning, real-time translation, and user interaction

import { Logger } from './lib/logger.js';

class TranslationContentScript {
  constructor() {
    this.logger = Logger.create('content-script');

    this.isInitialized = false;
    this.uiManager = null;
    this.contentObserver = null;
    this.isTranslating = false;
    this.autoTranslateEnabled = false;
    this.currentStrategy = 'smart';
    this.config = null;

    // Translation state
    this.translatedNodes = new WeakSet();
    this.pendingTranslations = new Map();
    this.selectionTimeout = null;

    // Performance tracking
    this.stats = {
      nodesTranslated: 0,
      requestsSent: 0,
      errorsCount: 0,
      startTime: null
    };

    this.initialize();
  }

  async initialize() {
    try {
      // Skip initialization for PDF viewer
      if (this.isPDFViewer()) return;

      await this.loadConfiguration();
      await this.loadCoreModules();
      this.setupEventListeners();
      this.setupMessageHandlers();

      if (this.config?.autoTranslateEnabled) {
        this.startAutoTranslation();
      }

      this.isInitialized = true;
      console.log('[TranslationContentScript] Initialized successfully');
    } catch (error) {
      console.error('[TranslationContentScript] Initialization failed:', error);
    }
  }

  isPDFViewer() {
    return chrome?.runtime?.getURL &&
           location.href.startsWith(chrome.runtime.getURL('pdfViewer.html'));
  }

  async loadConfiguration() {
    try {
      this.config = await this.sendMessage({ type: 'getConfig' });

      // Apply theme
      if (this.config?.theme) {
        this.applyTheme(this.config.theme);
      }
    } catch (error) {
      console.error('[TranslationContentScript] Failed to load config:', error);
      // Fallback configuration
      this.config = {
        sourceLanguage: 'auto',
        targetLanguage: 'en',
        strategy: 'smart',
        autoTranslateEnabled: false,
        theme: 'system'
      };
    }
  }

  async loadCoreModules() {
    // Load UI Manager
    if (typeof UIManager !== 'undefined') {
      this.uiManager = new UIManager();
    } else {
      console.warn('[TranslationContentScript] UIManager not available');
    }

    // Load Content Observer
    if (typeof ContentObserver !== 'undefined') {
      this.contentObserver = new ContentObserver(
        (nodes, options) => this.handleNewContent(nodes, options),
        {
          batchDelay: 300,
          maxBatchSize: 25,
          enableSmartFiltering: true
        }
      );
    } else {
      console.warn('[TranslationContentScript] ContentObserver not available');
    }
  }

  setupEventListeners() {
    // Selection translation
    document.addEventListener('mouseup', (e) => this.handleSelection(e));
    document.addEventListener('keyup', (e) => this.handleSelection(e));

    // Click outside to hide selection overlay
    document.addEventListener('mousedown', (e) => this.handleClickOutside(e));

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => this.handleKeyboard(e));

    // Page visibility changes
    document.addEventListener('visibilitychange', () => this.handleVisibilityChange());

    // Before unload cleanup
    window.addEventListener('beforeunload', () => this.cleanup());
  }

  setupMessageHandlers() {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      this.handleMessage(message, sender, sendResponse);
      return true; // Keep message channel open for async responses
    });
  }

  async handleMessage(message, sender, sendResponse) {
    try {
      switch (message.type) {
        case 'translatePage':
          await this.translatePage(message.options);
          sendResponse({ success: true });
          break;

        case 'translateSelection':
          await this.translateSelection(message.options);
          sendResponse({ success: true });
          break;

        case 'toggleAutoTranslate':
          this.toggleAutoTranslate(message.enabled);
          sendResponse({ success: true });
          break;

        case 'updateStrategy':
          this.updateStrategy(message.strategy);
          sendResponse({ success: true });
          break;

        case 'updateConfig':
          await this.updateConfiguration(message.config);
          sendResponse({ success: true });
          break;

        case 'getStats':
          sendResponse(this.getStats());
          break;

        default:
          sendResponse({ success: false, error: 'Unknown message type' });
      }
    } catch (error) {
      console.error('[TranslationContentScript] Message handler error:', error);
      sendResponse({ success: false, error: error.message });
    }
  }

  async translatePage(options = {}) {
    if (this.isTranslating) {
      this.uiManager?.showToast('Translation already in progress', 'warning');
      return;
    }

    try {
      this.isTranslating = true;
      this.stats.startTime = Date.now();

      // Show progress indicator
      const progressId = this.uiManager?.createProgressIndicator({
        title: 'Translating Page',
        onClose: () => this.stopTranslation()
      });

      // Scan document for translatable text
      const textNodes = this.scanDocument();

      if (textNodes.length === 0) {
        this.uiManager?.showToast('No translatable text found', 'warning');
        return;
      }

      // Batch and translate nodes
      const batches = this.createBatches(textNodes);
      let processed = 0;

      for (const batch of batches) {
        if (!this.isTranslating) break; // Check if translation was stopped

        await this.translateBatch(batch);
        processed += batch.length;

        // Update progress
        const percentage = (processed / textNodes.length) * 100;
        this.uiManager?.updateProgress(
          progressId,
          percentage,
          `Translated ${processed}/${textNodes.length} elements`
        );
      }

      // Show completion
      this.uiManager?.updateProgress(progressId, 100, 'Translation complete');
      setTimeout(() => {
        this.uiManager?.removeProgressIndicator(progressId);
        this.uiManager?.showToast(`Translated ${processed} elements`, 'success');
      }, 1000);

    } catch (error) {
      console.error('[TranslationContentScript] Page translation error:', error);
      this.uiManager?.showToast('Translation failed: ' + error.message, 'error');
    } finally {
      this.isTranslating = false;
    }
  }

  async translateSelection(options = {}) {
    const selection = window.getSelection();
    const text = selection.toString().trim();

    if (!text) {
      this.uiManager?.showToast('No text selected', 'warning');
      return;
    }

    try {
      // Show loading overlay
      const overlayId = this.uiManager?.createTranslationOverlay(
        selection.getRangeAt(0).getBoundingClientRect(),
        'Translating...',
        { loading: true }
      );

      // Translate text
      const result = await this.translateText(text);

      // Update overlay with result
      if (result.success) {
        this.uiManager?.updateOverlay(overlayId, result.translatedText);

        // Replace selected text
        if (options.replaceSelection) {
          this.replaceSelection(selection, result.translatedText);
        }
      } else {
        this.uiManager?.updateOverlay(overlayId, 'Translation failed', { error: true });
      }

      // Auto-hide overlay after delay
      setTimeout(() => {
        this.uiManager?.removeOverlay(overlayId);
      }, 3000);

    } catch (error) {
      console.error('[TranslationContentScript] Selection translation error:', error);
      this.uiManager?.showToast('Selection translation failed', 'error');
    }
  }

  scanDocument() {
    const textNodes = [];
    const walker = document.createTreeWalker(
      document.body,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: (node) => {
          return this.isTranslatableNode(node)
            ? NodeFilter.FILTER_ACCEPT
            : NodeFilter.FILTER_REJECT;
        }
      }
    );

    let node;
    while (node = walker.nextNode()) {
      if (!this.translatedNodes.has(node)) {
        textNodes.push(node);
      }
    }

    return textNodes;
  }

  isTranslatableNode(node) {
    if (node.nodeType !== Node.TEXT_NODE) return false;

    const text = node.textContent.trim();
    if (text.length < 3) return false;

    // Skip if only numbers, punctuation, or symbols
    if (!/\p{L}/u.test(text)) return false;

    const parent = node.parentElement;
    if (!parent) return false;

    // Skip certain elements
    const skipTags = ['SCRIPT', 'STYLE', 'NOSCRIPT', 'TEMPLATE', 'TEXTAREA', 'INPUT'];
    if (skipTags.includes(parent.tagName)) return false;

    // Skip no-translate elements
    if (parent.closest('[translate="no"], .notranslate, .no-translate')) return false;

    // Skip hidden elements
    const style = window.getComputedStyle(parent);
    if (style.display === 'none' || style.visibility === 'hidden') return false;

    return true;
  }

  createBatches(nodes, maxBatchSize = 20) {
    const batches = [];
    for (let i = 0; i < nodes.length; i += maxBatchSize) {
      batches.push(nodes.slice(i, i + maxBatchSize));
    }
    return batches;
  }

  async translateBatch(nodes) {
    const texts = nodes.map(node => node.textContent.trim());
    const uniqueTexts = [...new Set(texts)];

    if (uniqueTexts.length === 0) return;

    try {
      const result = await this.sendMessage({
        type: 'translateBatch',
        texts: uniqueTexts,
        sourceLanguage: this.config.sourceLanguage,
        targetLanguage: this.config.targetLanguage,
        strategy: this.currentStrategy
      });

      if (result.success) {
        // Create text mapping
        const translationMap = new Map();
        uniqueTexts.forEach((text, index) => {
          if (result.translations[index]) {
            translationMap.set(text, result.translations[index]);
          }
        });

        // Apply translations to nodes
        nodes.forEach(node => {
          const originalText = node.textContent.trim();
          const translation = translationMap.get(originalText);

          if (translation && translation !== originalText) {
            this.applyTranslation(node, translation);
            this.translatedNodes.add(node);
            this.stats.nodesTranslated++;
          }
        });

        this.stats.requestsSent++;
      } else {
        throw new Error(result.error || 'Translation failed');
      }
    } catch (error) {
      console.error('[TranslationContentScript] Batch translation error:', error);
      this.stats.errorsCount++;
      throw error;
    }
  }

  async translateText(text) {
    try {
      const result = await this.sendMessage({
        type: 'translateText',
        text: text,
        sourceLanguage: this.config.sourceLanguage,
        targetLanguage: this.config.targetLanguage,
        strategy: this.currentStrategy
      });

      return result;
    } catch (error) {
      console.error('[TranslationContentScript] Text translation error:', error);
      return { success: false, error: error.message };
    }
  }

  applyTranslation(node, translatedText) {
    // Preserve leading and trailing whitespace
    const original = node.textContent;
    const leadingSpace = original.match(/^\s*/)[0];
    const trailingSpace = original.match(/\s*$/)[0];

    node.textContent = leadingSpace + translatedText + trailingSpace;

    // Add visual indicator
    if (node.parentElement) {
      node.parentElement.classList.add('translated');
      node.parentElement.setAttribute('data-original', original.trim());
      node.parentElement.setAttribute('data-translated', translatedText);
    }
  }

  handleSelection(event) {
    // Debounce selection handling
    clearTimeout(this.selectionTimeout);
    this.selectionTimeout = setTimeout(() => {
      const selection = window.getSelection();
      const text = selection.toString().trim();

      if (text && text.length > 2) {
        this.showSelectionOverlay(selection);
      } else {
        this.hideSelectionOverlay();
      }
    }, 200);
  }

  showSelectionOverlay(selection) {
    if (!this.uiManager) return;

    const overlayId = this.uiManager.createSelectionOverlay(
      selection,
      (selectedText) => {
        this.translateSelection({ replaceSelection: false });
      }
    );
  }

  hideSelectionOverlay() {
    // UI Manager handles this automatically
  }

  handleClickOutside(event) {
    // Hide selection overlay if clicking outside
    if (!event.target.closest('.translation-selection-overlay')) {
      this.hideSelectionOverlay();
    }
  }

  handleKeyboard(event) {
    // Escape to hide overlays
    if (event.key === 'Escape') {
      this.hideSelectionOverlay();
    }

    // Ctrl+Shift+T to translate page
    if (event.ctrlKey && event.shiftKey && event.key === 'T') {
      event.preventDefault();
      this.translatePage();
    }
  }

  handleVisibilityChange() {
    if (document.hidden) {
      // Pause translation when page is hidden
      this.stopTranslation();
    } else if (this.autoTranslateEnabled) {
      // Resume auto-translation when page becomes visible
      this.startAutoTranslation();
    }
  }

  handleNewContent(nodes, options = {}) {
    if (!this.autoTranslateEnabled) return;

    // Filter translatable nodes
    const translatableNodes = nodes.filter(node => this.isTranslatableNode(node));

    if (translatableNodes.length === 0) return;

    // Prioritize visible content
    if (options.visible) {
      this.translateBatch(translatableNodes).catch(console.error);
    } else {
      // Queue for later translation
      setTimeout(() => {
        this.translateBatch(translatableNodes).catch(console.error);
      }, 1000);
    }
  }

  startAutoTranslation() {
    this.autoTranslateEnabled = true;

    if (this.contentObserver) {
      this.contentObserver.startObserving();
    }

    // Translate existing content
    this.translatePage().catch(console.error);
  }

  stopTranslation() {
    this.isTranslating = false;
    this.autoTranslateEnabled = false;

    if (this.contentObserver) {
      this.contentObserver.stopObserving();
    }
  }

  toggleAutoTranslate(enabled) {
    if (enabled) {
      this.startAutoTranslation();
    } else {
      this.stopTranslation();
    }
  }

  updateStrategy(strategy) {
    this.currentStrategy = strategy;
  }

  async updateConfiguration(newConfig) {
    this.config = { ...this.config, ...newConfig };

    if (newConfig.theme) {
      this.applyTheme(newConfig.theme);
    }
  }

  applyTheme(theme) {
    // Apply theme to document
    document.documentElement.setAttribute('data-translation-theme', theme);
  }

  replaceSelection(selection, newText) {
    const range = selection.getRangeAt(0);
    range.deleteContents();
    range.insertNode(document.createTextNode(newText));
    selection.removeAllRanges();
  }

  sendMessage(message) {
    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage(message, (response) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(response);
        }
      });
    });
  }

  getStats() {
    return {
      ...this.stats,
      isInitialized: this.isInitialized,
      isTranslating: this.isTranslating,
      autoTranslateEnabled: this.autoTranslateEnabled,
      translatedNodesCount: this.translatedNodes ? 'WeakSet' : 0,
      currentStrategy: this.currentStrategy
    };
  }

  cleanup() {
    this.stopTranslation();

    if (this.contentObserver) {
      this.contentObserver.destroy();
    }

    if (this.uiManager) {
      this.uiManager.cleanup();
    }

    // Clear timeouts
    if (this.selectionTimeout) {
      clearTimeout(this.selectionTimeout);
    }
  }
}

// Check if we should skip initialization (PDF viewer)
const skipInit = chrome && chrome.runtime && chrome.runtime.getURL &&
  location.href.startsWith(chrome.runtime.getURL('pdfViewer.html'));

// Load core modules dynamically
const loadCoreModules = async () => {
  if (!chrome?.runtime?.getURL) return false;

  const modules = [
    { src: 'core/ui-manager.js', name: 'UIManager' },
    { src: 'core/content-observer.js', name: 'ContentObserver' }
  ];

  try {
    for (const module of modules) {
      if (!window[module.name]) {
        const script = document.createElement('script');
        script.src = chrome.runtime.getURL(module.src);
        document.head.appendChild(script);

        // Wait for script to load
        await new Promise((resolve, reject) => {
          script.onload = resolve;
          script.onerror = reject;
        });
      }
    }
    return true;
  } catch (error) {
    console.error('[TranslationContentScript] Failed to load core modules:', error);
    return false;
  }
};

// PDF embed replacement
function replacePdfEmbeds() {
  if (location.protocol !== 'http:' && location.protocol !== 'https:') return;

  if (!chrome?.runtime?.getURL) return;

  const viewerBase = chrome.runtime.getURL('pdfViewer.html');
  const embeds = document.querySelectorAll(
    'embed[type="application/pdf"],embed[src$=".pdf"],iframe[src$=".pdf"]'
  );

  embeds.forEach(el => {
    const url = el.src;
    if (!url || url.startsWith('about:') || url.startsWith('chrome')) return;

    const iframe = document.createElement('iframe');
    iframe.src = viewerBase + '?file=' + encodeURIComponent(url);
    iframe.style.width = el.style.width || el.getAttribute('width') || '100%';
    iframe.style.height = el.style.height || el.getAttribute('height') || '600px';
    el.replaceWith(iframe);
  });
}

// Initialize the extension
async function initializeExtension() {
  try {
    // Skip initialization for PDF viewer
    if (skipInit) return;

    // Load core modules
    await loadCoreModules();

    // Replace PDF embeds
    replacePdfEmbeds();

    // Initialize main content script
    const contentScript = new TranslationContentScript();

    // Make available globally for debugging
    window.__translationContentScript = contentScript;

  } catch (error) {
    console.error('[TranslationContentScript] Failed to initialize extension:', error);
  }
}

// Start initialization when DOM is ready
if (document.readyState === 'complete' || document.readyState === 'interactive') {
  initializeExtension();
} else {
  document.addEventListener('DOMContentLoaded', initializeExtension);
}

// Module exports for testing - maintain legacy API compatibility
if (typeof module !== 'undefined' && module.exports) {
  // Legacy API compatibility for existing tests
  let currentConfig = {};
  let controllerCount = 0;

  const setCurrentConfig = (config) => {
    currentConfig = config;
  };

  const collectNodes = (element, nodes) => {
    const walker = document.createTreeWalker(
      element,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: (node) => {
          if (node.textContent.trim().length < 3) return NodeFilter.FILTER_REJECT;
          const parent = node.parentElement;
          if (!parent) return NodeFilter.FILTER_REJECT;

          const tagName = parent.tagName.toLowerCase();
          if (['script', 'style', 'noscript', 'template'].includes(tagName)) {
            return NodeFilter.FILTER_REJECT;
          }

          return NodeFilter.FILTER_ACCEPT;
        }
      }
    );

    let node;
    while (node = walker.nextNode()) {
      nodes.push(node);
    }
  };

  const translateBatch = async (nodes) => {
    controllerCount++;
    // Mock translation for testing
    return Promise.resolve();
  };

  module.exports = {
    TranslationContentScript,
    loadCoreModules,
    replacePdfEmbeds,
    initializeExtension,
    setCurrentConfig,
    collectNodes,
    translateBatch,
    get __controllerCount() { return controllerCount; }
  };
}