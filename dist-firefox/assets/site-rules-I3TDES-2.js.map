{"version":3,"file":"site-rules-I3TDES-2.js","sources":["../../src/core/glossary.ts","../../src/core/site-rules.ts"],"sourcesContent":["/**\n * Glossary - Custom term replacements for translations\n *\n * Features:\n * - Pre-processing: Replace terms before sending to translator\n * - Post-processing: Restore placeholder-protected terms after translation\n * - Case sensitivity options\n * - Import/export as JSON\n */\n\nimport { createLogger } from './logger';\n\nconst log = createLogger('Glossary');\n\nexport interface GlossaryTerm {\n  replacement: string;\n  caseSensitive: boolean;\n  description?: string;\n}\n\nexport interface GlossaryStore {\n  [term: string]: GlossaryTerm;\n}\n\n// Placeholder format for protecting terms during translation\nconst PLACEHOLDER_PREFIX = '\\u200B\\u2063TERM_';\nconst PLACEHOLDER_SUFFIX = '\\u2063\\u200B';\n\nconst STORAGE_KEY = 'glossary';\n\n/**\n * Get the entire glossary\n */\nexport async function getGlossary(): Promise<GlossaryStore> {\n  try {\n    const data = await chrome.storage.local.get(STORAGE_KEY);\n    return data[STORAGE_KEY] || {};\n  } catch (e) {\n    log.error(' Failed to get glossary:', e);\n    return {};\n  }\n}\n\n/**\n * Add or update a glossary term\n */\nexport async function addTerm(\n  term: string,\n  replacement: string,\n  caseSensitive = false,\n  description?: string\n): Promise<void> {\n  if (!term || !replacement) {\n    throw new Error('Term and replacement are required');\n  }\n\n  try {\n    const glossary = await getGlossary();\n    glossary[term] = { replacement, caseSensitive, description };\n    await chrome.storage.local.set({ [STORAGE_KEY]: glossary });\n    log.info(' Added term:', term, '->', replacement);\n  } catch (e) {\n    log.error(' Failed to add term:', e);\n    throw e;\n  }\n}\n\n/**\n * Remove a glossary term\n */\nexport async function removeTerm(term: string): Promise<void> {\n  try {\n    const glossary = await getGlossary();\n    delete glossary[term];\n    await chrome.storage.local.set({ [STORAGE_KEY]: glossary });\n    log.info(' Removed term:', term);\n  } catch (e) {\n    log.error(' Failed to remove term:', e);\n    throw e;\n  }\n}\n\n/**\n * Clear all glossary terms\n */\nexport async function clearGlossary(): Promise<void> {\n  try {\n    await chrome.storage.local.remove(STORAGE_KEY);\n    log.info(' Cleared glossary');\n  } catch (e) {\n    log.error(' Failed to clear glossary:', e);\n    throw e;\n  }\n}\n\n/**\n * Create a regex for matching a term (with case sensitivity)\n */\nfunction createTermRegex(term: string, caseSensitive: boolean): RegExp {\n  // Escape special regex characters\n  const escaped = term.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  // Word boundary matching\n  return new RegExp(`\\\\b${escaped}\\\\b`, caseSensitive ? 'g' : 'gi');\n}\n\n/**\n * Apply glossary pre-processing to text before translation\n * Replaces terms with their target replacements\n *\n * @param text - Text to process\n * @param glossary - Glossary terms to apply\n * @returns Processed text with replacements\n */\nexport function applyGlossaryPreProcess(text: string, glossary: GlossaryStore): string {\n  let result = text;\n\n  // Sort terms by length (longest first) to avoid partial matches\n  const sortedTerms = Object.keys(glossary).sort((a, b) => b.length - a.length);\n\n  for (const term of sortedTerms) {\n    const entry = glossary[term];\n    const regex = createTermRegex(term, entry.caseSensitive);\n    result = result.replace(regex, entry.replacement);\n  }\n\n  return result;\n}\n\n/**\n * Apply glossary with placeholder protection\n * Replaces terms with placeholders that survive translation\n *\n * @param text - Text to process\n * @param glossary - Glossary terms to apply\n * @returns Object with processed text and placeholder map for restoration\n */\nexport function applyGlossaryWithPlaceholders(\n  text: string,\n  glossary: GlossaryStore\n): { text: string; placeholderMap: Map<string, string> } {\n  let result = text;\n  const placeholderMap = new Map<string, string>();\n  let placeholderIndex = 0;\n\n  // Sort terms by length (longest first) to avoid partial matches\n  const sortedTerms = Object.keys(glossary).sort((a, b) => b.length - a.length);\n\n  for (const term of sortedTerms) {\n    const entry = glossary[term];\n    const regex = createTermRegex(term, entry.caseSensitive);\n\n    result = result.replace(regex, () => {\n      const placeholder = `${PLACEHOLDER_PREFIX}${placeholderIndex}${PLACEHOLDER_SUFFIX}`;\n      placeholderMap.set(placeholder, entry.replacement);\n      placeholderIndex++;\n      return placeholder;\n    });\n  }\n\n  return { text: result, placeholderMap };\n}\n\n/**\n * Restore placeholders with their actual replacements\n *\n * @param text - Translated text with placeholders\n * @param placeholderMap - Map of placeholders to replacements\n * @returns Text with placeholders replaced by actual terms\n */\nexport function restorePlaceholders(text: string, placeholderMap: Map<string, string>): string {\n  let result = text;\n\n  for (const [placeholder, replacement] of placeholderMap) {\n    result = result.split(placeholder).join(replacement);\n  }\n\n  return result;\n}\n\n/**\n * Convenience function: Apply glossary to text for translation\n * Uses placeholder method for protection during translation\n *\n * @param text - Original text\n * @param glossary - Glossary to apply (optional, will load from storage if not provided)\n * @returns Object with processed text and restore function\n */\nexport async function applyGlossary(\n  text: string,\n  glossary?: GlossaryStore\n): Promise<{ processedText: string; restore: (translated: string) => string }> {\n  const g = glossary ?? (await getGlossary());\n\n  if (Object.keys(g).length === 0) {\n    return { processedText: text, restore: (t) => t };\n  }\n\n  const { text: processedText, placeholderMap } = applyGlossaryWithPlaceholders(text, g);\n\n  return {\n    processedText,\n    restore: (translated: string) => restorePlaceholders(translated, placeholderMap),\n  };\n}\n\n/**\n * Apply glossary to an array of texts\n */\nexport async function applyGlossaryBatch(\n  texts: string[],\n  glossary?: GlossaryStore\n): Promise<{ processedTexts: string[]; restoreFns: Array<(text: string) => string> }> {\n  const g = glossary ?? (await getGlossary());\n\n  if (Object.keys(g).length === 0) {\n    return { processedTexts: texts, restoreFns: texts.map(() => (t: string) => t) };\n  }\n\n  const results = texts.map((text) => {\n    const { text: processedText, placeholderMap } = applyGlossaryWithPlaceholders(text, g);\n    return {\n      processedText,\n      restore: (translated: string) => restorePlaceholders(translated, placeholderMap),\n    };\n  });\n\n  return {\n    processedTexts: results.map((r) => r.processedText),\n    restoreFns: results.map((r) => r.restore),\n  };\n}\n\n/**\n * Export glossary as JSON string\n */\nexport async function exportGlossary(): Promise<string> {\n  const glossary = await getGlossary();\n  return JSON.stringify(glossary, null, 2);\n}\n\n/**\n * Import glossary from JSON string\n * Merges with existing glossary (imported terms take precedence)\n */\nexport async function importGlossary(json: string): Promise<number> {\n  try {\n    const imported: GlossaryStore = JSON.parse(json);\n\n    // Validate structure\n    for (const [term, entry] of Object.entries(imported)) {\n      if (typeof term !== 'string') {\n        throw new Error(`Invalid term: ${term}`);\n      }\n      if (typeof entry !== 'object' || entry === null) {\n        throw new Error(`Invalid entry for term: ${term}`);\n      }\n      if (typeof entry.replacement !== 'string') {\n        throw new Error(`Invalid replacement for term: ${term}`);\n      }\n      if (typeof entry.caseSensitive !== 'boolean') {\n        throw new Error(`Invalid caseSensitive for term: ${term}`);\n      }\n    }\n\n    const existing = await getGlossary();\n    const merged = { ...existing, ...imported };\n\n    await chrome.storage.local.set({ [STORAGE_KEY]: merged });\n    log.info(' Imported', Object.keys(imported).length, 'terms');\n\n    return Object.keys(imported).length;\n  } catch (e) {\n    log.error(' Failed to import glossary:', e);\n    throw e;\n  }\n}\n\nexport const glossary = {\n  getGlossary,\n  addTerm,\n  removeTerm,\n  clearGlossary,\n  applyGlossary,\n  applyGlossaryBatch,\n  applyGlossaryPreProcess,\n  applyGlossaryWithPlaceholders,\n  restorePlaceholders,\n  exportGlossary,\n  importGlossary,\n};\n\nexport default glossary;\n","/**\n * Per-site translation rules\n * Stores and retrieves site-specific translation preferences\n *\n * Features:\n * - Per-hostname preferences (auto-translate, provider, languages)\n * - Wildcard matching (*.example.com)\n * - Persistent storage via chrome.storage.local\n */\n\nimport type { TranslationProviderId, Strategy } from '../types';\nimport { createLogger } from './logger';\n\nconst log = createLogger('SiteRules');\n\nexport interface SiteRules {\n  autoTranslate: boolean;\n  preferredProvider?: TranslationProviderId;\n  sourceLang?: string;\n  targetLang?: string;\n  strategy?: Strategy;\n}\n\nexport interface SiteRulesStore {\n  [hostname: string]: SiteRules;\n}\n\nconst STORAGE_KEY = 'siteRules';\n\n/**\n * Check if hostname matches a wildcard pattern\n * Supports patterns like *.example.com\n */\nexport function matchesPattern(hostname: string, pattern: string): boolean {\n  if (pattern === hostname) {\n    return true;\n  }\n\n  // Handle wildcard patterns\n  if (pattern.startsWith('*.')) {\n    const baseDomain = pattern.slice(2);\n    // Match exact domain or any subdomain\n    return hostname === baseDomain || hostname.endsWith('.' + baseDomain);\n  }\n\n  return false;\n}\n\n/**\n * Find the best matching rule for a hostname\n * Exact matches take precedence over wildcard matches\n */\nexport function findMatchingRule(\n  hostname: string,\n  rules: SiteRulesStore\n): { pattern: string; rules: SiteRules } | null {\n  // First check for exact match\n  if (rules[hostname]) {\n    return { pattern: hostname, rules: rules[hostname] };\n  }\n\n  // Then check wildcard patterns (sorted by specificity)\n  const wildcardPatterns = Object.keys(rules)\n    .filter((pattern) => pattern.startsWith('*.'))\n    .sort((a, b) => b.length - a.length); // More specific patterns first\n\n  for (const pattern of wildcardPatterns) {\n    if (matchesPattern(hostname, pattern)) {\n      return { pattern, rules: rules[pattern] };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get site rules for a hostname\n * Returns matching rules considering wildcard patterns\n */\nexport async function getRules(hostname: string): Promise<SiteRules | null> {\n  try {\n    const data = await chrome.storage.local.get(STORAGE_KEY);\n    const allRules: SiteRulesStore = data[STORAGE_KEY] || {};\n\n    const match = findMatchingRule(hostname, allRules);\n    return match ? match.rules : null;\n  } catch (e) {\n    log.error(' Failed to get rules:', e);\n    return null;\n  }\n}\n\n/**\n * Set site rules for a specific hostname or pattern\n */\nexport async function setRules(hostnameOrPattern: string, rules: SiteRules): Promise<void> {\n  try {\n    const data = await chrome.storage.local.get(STORAGE_KEY);\n    const allRules: SiteRulesStore = data[STORAGE_KEY] || {};\n\n    allRules[hostnameOrPattern] = rules;\n\n    await chrome.storage.local.set({ [STORAGE_KEY]: allRules });\n    log.info(' Updated rules for:', hostnameOrPattern, rules);\n  } catch (e) {\n    log.error(' Failed to set rules:', e);\n    throw e;\n  }\n}\n\n/**\n * Clear site rules for a specific hostname or pattern\n */\nexport async function clearRules(hostnameOrPattern: string): Promise<void> {\n  try {\n    const data = await chrome.storage.local.get(STORAGE_KEY);\n    const allRules: SiteRulesStore = data[STORAGE_KEY] || {};\n\n    delete allRules[hostnameOrPattern];\n\n    await chrome.storage.local.set({ [STORAGE_KEY]: allRules });\n    log.info(' Cleared rules for:', hostnameOrPattern);\n  } catch (e) {\n    log.error(' Failed to clear rules:', e);\n    throw e;\n  }\n}\n\n/**\n * Get all site rules\n */\nexport async function getAllRules(): Promise<SiteRulesStore> {\n  try {\n    const data = await chrome.storage.local.get(STORAGE_KEY);\n    return data[STORAGE_KEY] || {};\n  } catch (e) {\n    log.error(' Failed to get all rules:', e);\n    return {};\n  }\n}\n\n/**\n * Clear all site rules\n */\nexport async function clearAllRules(): Promise<void> {\n  try {\n    await chrome.storage.local.remove(STORAGE_KEY);\n    log.info(' Cleared all rules');\n  } catch (e) {\n    log.error(' Failed to clear all rules:', e);\n    throw e;\n  }\n}\n\n/**\n * Export rules as JSON string\n */\nexport async function exportRules(): Promise<string> {\n  const rules = await getAllRules();\n  return JSON.stringify(rules, null, 2);\n}\n\n/**\n * Import rules from JSON string\n * Merges with existing rules (imported rules take precedence)\n */\nexport async function importRules(json: string): Promise<number> {\n  try {\n    const imported: SiteRulesStore = JSON.parse(json);\n\n    // Validate structure\n    for (const [hostname, rules] of Object.entries(imported)) {\n      if (typeof hostname !== 'string') {\n        throw new Error(`Invalid hostname: ${hostname}`);\n      }\n      if (typeof rules !== 'object' || rules === null) {\n        throw new Error(`Invalid rules for ${hostname}`);\n      }\n      if (typeof rules.autoTranslate !== 'boolean') {\n        throw new Error(`Invalid autoTranslate for ${hostname}`);\n      }\n    }\n\n    const existing = await getAllRules();\n    const merged = { ...existing, ...imported };\n\n    await chrome.storage.local.set({ [STORAGE_KEY]: merged });\n    log.info(' Imported', Object.keys(imported).length, 'rules');\n\n    return Object.keys(imported).length;\n  } catch (e) {\n    log.error(' Failed to import rules:', e);\n    throw e;\n  }\n}\n\nexport const siteRules = {\n  getRules,\n  setRules,\n  clearRules,\n  getAllRules,\n  clearAllRules,\n  exportRules,\n  importRules,\n  matchesPattern,\n  findMatchingRule,\n};\n\nexport default siteRules;\n"],"names":["log","createLogger","PLACEHOLDER_PREFIX","PLACEHOLDER_SUFFIX","STORAGE_KEY","getGlossary","addTerm","term","replacement","caseSensitive","description","glossary","e","removeTerm","clearGlossary","createTermRegex","escaped","applyGlossaryPreProcess","text","result","sortedTerms","a","b","entry","regex","applyGlossaryWithPlaceholders","placeholderMap","placeholderIndex","placeholder","restorePlaceholders","applyGlossary","g","t","processedText","translated","applyGlossaryBatch","texts","results","exportGlossary","importGlossary","json","imported","merged","matchesPattern","hostname","pattern","baseDomain","findMatchingRule","rules","wildcardPatterns","getRules","allRules","match","setRules","hostnameOrPattern","clearRules","getAllRules","clearAllRules","exportRules","importRules","siteRules"],"mappings":"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"}