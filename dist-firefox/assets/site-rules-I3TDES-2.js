import{c as m}from"./storage--5bP51BW.js";const l=m("Glossary"),x="​⁣TERM_",O="⁣​",d="glossary";async function u(){try{return(await chrome.storage.local.get(d))[d]||{}}catch(e){return l.error(" Failed to get glossary:",e),{}}}async function T(e,t,o=!1,s){if(!e||!t)throw new Error("Term and replacement are required");try{const r=await u();r[e]={replacement:t,caseSensitive:o,description:s},await chrome.storage.local.set({[d]:r}),l.info(" Added term:",e,"->",t)}catch(r){throw l.error(" Failed to add term:",r),r}}async function v(e){try{const t=await u();delete t[e],await chrome.storage.local.set({[d]:t}),l.info(" Removed term:",e)}catch(t){throw l.error(" Failed to remove term:",t),t}}async function F(){try{await chrome.storage.local.remove(d),l.info(" Cleared glossary")}catch(e){throw l.error(" Failed to clear glossary:",e),e}}function w(e,t){const o=e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");return new RegExp(`\\b${o}\\b`,t?"g":"gi")}function $(e,t){let o=e;const s=Object.keys(t).sort((r,a)=>a.length-r.length);for(const r of s){const a=t[r],i=w(r,a.caseSensitive);o=o.replace(i,a.replacement)}return o}function g(e,t){let o=e;const s=new Map;let r=0;const a=Object.keys(t).sort((i,f)=>f.length-i.length);for(const i of a){const f=t[i],b=w(i,f.caseSensitive);o=o.replace(b,()=>{const p=`${x}${r}${O}`;return s.set(p,f.replacement),r++,p})}return{text:o,placeholderMap:s}}function y(e,t){let o=e;for(const[s,r]of t)o=o.split(s).join(r);return o}async function j(e,t){const o=t??await u();if(Object.keys(o).length===0)return{processedText:e,restore:a=>a};const{text:s,placeholderMap:r}=g(e,o);return{processedText:s,restore:a=>y(a,r)}}async function I(e,t){const o=t??await u();if(Object.keys(o).length===0)return{processedTexts:e,restoreFns:e.map(()=>r=>r)};const s=e.map(r=>{const{text:a,placeholderMap:i}=g(r,o);return{processedText:a,restore:f=>y(f,i)}});return{processedTexts:s.map(r=>r.processedText),restoreFns:s.map(r=>r.restore)}}async function S(){const e=await u();return JSON.stringify(e,null,2)}async function G(e){try{const t=JSON.parse(e);for(const[r,a]of Object.entries(t)){if(typeof r!="string")throw new Error(`Invalid term: ${r}`);if(typeof a!="object"||a===null)throw new Error(`Invalid entry for term: ${r}`);if(typeof a.replacement!="string")throw new Error(`Invalid replacement for term: ${r}`);if(typeof a.caseSensitive!="boolean")throw new Error(`Invalid caseSensitive for term: ${r}`)}const s={...await u(),...t};return await chrome.storage.local.set({[d]:s}),l.info(" Imported",Object.keys(t).length,"terms"),Object.keys(t).length}catch(t){throw l.error(" Failed to import glossary:",t),t}}const J={getGlossary:u,addTerm:T,removeTerm:v,clearGlossary:F,applyGlossary:j,applyGlossaryBatch:I,applyGlossaryPreProcess:$,applyGlossaryWithPlaceholders:g,restorePlaceholders:y,exportGlossary:S,importGlossary:G},c=m("SiteRules"),n="siteRules";function R(e,t){if(t===e)return!0;if(t.startsWith("*.")){const o=t.slice(2);return e===o||e.endsWith("."+o)}return!1}function E(e,t){if(t[e])return{pattern:e,rules:t[e]};const o=Object.keys(t).filter(s=>s.startsWith("*.")).sort((s,r)=>r.length-s.length);for(const s of o)if(R(e,s))return{pattern:s,rules:t[s]};return null}async function k(e){try{const o=(await chrome.storage.local.get(n))[n]||{},s=E(e,o);return s?s.rules:null}catch(t){return c.error(" Failed to get rules:",t),null}}async function A(e,t){try{const s=(await chrome.storage.local.get(n))[n]||{};s[e]=t,await chrome.storage.local.set({[n]:s}),c.info(" Updated rules for:",e,t)}catch(o){throw c.error(" Failed to set rules:",o),o}}async function P(e){try{const o=(await chrome.storage.local.get(n))[n]||{};delete o[e],await chrome.storage.local.set({[n]:o}),c.info(" Cleared rules for:",e)}catch(t){throw c.error(" Failed to clear rules:",t),t}}async function h(){try{return(await chrome.storage.local.get(n))[n]||{}}catch(e){return c.error(" Failed to get all rules:",e),{}}}async function M(){try{await chrome.storage.local.remove(n),c.info(" Cleared all rules")}catch(e){throw c.error(" Failed to clear all rules:",e),e}}async function C(){const e=await h();return JSON.stringify(e,null,2)}async function L(e){try{const t=JSON.parse(e);for(const[r,a]of Object.entries(t)){if(typeof r!="string")throw new Error(`Invalid hostname: ${r}`);if(typeof a!="object"||a===null)throw new Error(`Invalid rules for ${r}`);if(typeof a.autoTranslate!="boolean")throw new Error(`Invalid autoTranslate for ${r}`)}const s={...await h(),...t};return await chrome.storage.local.set({[n]:s}),c.info(" Imported",Object.keys(t).length,"rules"),Object.keys(t).length}catch(t){throw c.error(" Failed to import rules:",t),t}}const N={getRules:k,setRules:A,clearRules:P,getAllRules:h,clearAllRules:M,exportRules:C,importRules:L,matchesPattern:R,findMatchingRule:E};export{J as g,N as s};
//# sourceMappingURL=site-rules-I3TDES-2.js.map
