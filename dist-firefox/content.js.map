{"version":3,"file":"content.js","sources":["../src/content/index.ts"],"sourcesContent":["/**\n * Content Script\n * Handles DOM scanning and text replacement for translations\n *\n * Features:\n * - MutationObserver for dynamic content\n * - Graceful degradation on translation failures\n * - Skip untranslatable elements (scripts, styles, inputs)\n * - Throttled translation to prevent rate limiting\n * - Per-site rules for automatic translation preferences\n * - Glossary support for custom term replacements\n */\n\nimport type { Strategy, TranslationProviderId, TranslateResponse } from '../types';\nimport { siteRules } from '../core/site-rules';\nimport { glossary, type GlossaryStore } from '../core/glossary';\nimport { CONFIG } from '../config';\nimport { createLogger } from '../core/logger';\nimport { safeStorageGet } from '../core/storage';\nimport { browserAPI } from '../core/browser-api';\nimport { measureTimeAsync } from '../core/profiler';\n\nconst log = createLogger('Content');\n\n// Simple content-script timing tracker (separate from background profiler)\nconst contentTimings: {\n  domScan: number[];\n  domUpdate: number[];\n  glossaryApply: number[];\n  ipcRoundtrip: number[];\n} = {\n  domScan: [],\n  domUpdate: [],\n  glossaryApply: [],\n  ipcRoundtrip: [],\n};\n\nfunction recordContentTiming(category: keyof typeof contentTimings, durationMs: number): void {\n  const arr = contentTimings[category];\n  arr.push(durationMs);\n  // Keep last 100 entries\n  if (arr.length > 100) arr.shift();\n}\n\nfunction getContentTimingStats(): Record<string, { avg: number; min: number; max: number; count: number }> {\n  const result: Record<string, { avg: number; min: number; max: number; count: number }> = {};\n  for (const [key, arr] of Object.entries(contentTimings)) {\n    if (arr.length === 0) continue;\n    const sum = arr.reduce((a, b) => a + b, 0);\n    result[key] = {\n      avg: sum / arr.length,\n      min: Math.min(...arr),\n      max: Math.max(...arr),\n      count: arr.length,\n    };\n  }\n  return result;\n}\n\n// Content-script specific message types (extend base types)\ninterface TranslateSelectionMessage {\n  type: 'translateSelection';\n  sourceLang: string;\n  targetLang: string;\n  strategy: Strategy;\n  provider?: string;\n}\n\ninterface TranslatePageMessage {\n  type: 'translatePage';\n  sourceLang: string;\n  targetLang: string;\n  strategy: Strategy;\n  provider?: string;\n}\n\ntype ContentMessage = TranslateSelectionMessage | TranslatePageMessage | { type: 'ping' } | { type: 'stopAutoTranslate' };\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n// Elements to skip during translation\nconst SKIP_TAGS = new Set([\n  'SCRIPT',\n  'STYLE',\n  'NOSCRIPT',\n  'TEMPLATE',\n  'CODE',\n  'PRE',\n  'TEXTAREA',\n  'INPUT',\n  'SELECT',\n  'BUTTON',\n  'SVG',\n  'MATH',\n  'CANVAS',\n  'VIDEO',\n  'AUDIO',\n  'IFRAME',\n  'OBJECT',\n  'EMBED',\n]);\n\n// Mark translated nodes to avoid re-translation\nconst TRANSLATED_ATTR = 'data-translated';\n\n// ============================================================================\n// State\n// ============================================================================\n\nlet isTranslating = false;\nlet pendingMutations: MutationRecord[] = [];\nlet mutationDebounceTimer: number | null = null;\nlet mutationObserver: MutationObserver | null = null;\nlet currentSettings: {\n  sourceLang: string;\n  targetLang: string;\n  strategy: Strategy;\n  provider?: string;\n} | null = null;\n\n// Cache for glossary terms (loaded once per page)\nlet cachedGlossary: GlossaryStore | null = null;\n\n// ============================================================================\n// Element Filtering\n// ============================================================================\n\n/**\n * Check if element should be skipped for translation\n */\nfunction shouldSkip(element: Element): boolean {\n  // Skip by tag name\n  if (SKIP_TAGS.has(element.tagName)) return true;\n\n  // Skip already translated\n  if (element.getAttribute(TRANSLATED_ATTR)) return true;\n\n  // Skip elements with contenteditable\n  if (element.closest('[contenteditable=\"true\"]')) return true;\n\n  // Skip elements marked as no-translate\n  if (element.hasAttribute('data-no-translate')) return true;\n\n  // Skip elements with translate=\"no\"\n  if (element.getAttribute('translate') === 'no') return true;\n\n  // Check visibility\n  try {\n    const style = window.getComputedStyle(element);\n    if (style.display === 'none' || style.visibility === 'hidden') return true;\n  } catch {\n    // getComputedStyle can throw for detached elements\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Validate text for translation\n */\nfunction isValidText(text: string | null): text is string {\n  if (!text) return false;\n\n  const trimmed = text.trim();\n  if (trimmed.length < CONFIG.batching.minTextLength) return false;\n  if (trimmed.length > CONFIG.batching.maxTextLength) return false;\n\n  // Skip text that's only whitespace, numbers, or symbols\n  if (/^[\\s\\d\\p{P}\\p{S}]+$/u.test(trimmed)) return false;\n\n  // Skip text that looks like code or URLs\n  if (/^(https?:|www\\.|\\/\\/|{|}|\\[|\\]|function|const |let |var )/.test(trimmed)) return false;\n\n  return true;\n}\n\n/**\n * Sanitize text for translation - remove problematic characters\n */\nfunction sanitizeText(text: string): string {\n  return text\n    .normalize('NFC')\n    .replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, '')\n    .replace(/[ \\t]+/g, ' ')\n    .trim();\n}\n\n// ============================================================================\n// DOM Traversal\n// ============================================================================\n\n/**\n * Get all translatable text nodes in element\n */\nfunction getTextNodes(root: Element): Text[] {\n  const nodes: Text[] = [];\n\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {\n    acceptNode: (node) => {\n      const parent = node.parentElement;\n      if (!parent || shouldSkip(parent)) return NodeFilter.FILTER_REJECT;\n      if (!isValidText(node.textContent)) return NodeFilter.FILTER_REJECT;\n      return NodeFilter.FILTER_ACCEPT;\n    },\n  });\n\n  let node: Node | null;\n  while ((node = walker.nextNode())) {\n    nodes.push(node as Text);\n  }\n\n  return nodes;\n}\n\n/**\n * Get text nodes from a specific set of elements (for mutations)\n */\nfunction getTextNodesFromNodes(nodes: Node[]): Text[] {\n  const textNodes: Text[] = [];\n\n  for (const node of nodes) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      const parent = node.parentElement;\n      if (parent && !shouldSkip(parent) && isValidText(node.textContent)) {\n        textNodes.push(node as Text);\n      }\n    } else if (node.nodeType === Node.ELEMENT_NODE) {\n      const element = node as Element;\n      if (!shouldSkip(element)) {\n        textNodes.push(...getTextNodes(element));\n      }\n    }\n  }\n\n  return textNodes;\n}\n\n// ============================================================================\n// Translation Functions\n// ============================================================================\n\n/**\n * Load glossary if not cached\n */\nasync function loadGlossary(): Promise<GlossaryStore> {\n  if (cachedGlossary === null) {\n    try {\n      cachedGlossary = await glossary.getGlossary();\n    } catch (e) {\n      log.error(' Failed to load glossary:', e);\n      cachedGlossary = {};\n    }\n  }\n  return cachedGlossary;\n}\n\n/**\n * Translate selected text with error handling\n */\nasync function translateSelection(\n  sourceLang: string,\n  targetLang: string,\n  strategy: Strategy,\n  provider?: string\n): Promise<void> {\n  const selection = window.getSelection();\n  if (!selection || selection.isCollapsed) {\n    log.info(' No text selected');\n    return;\n  }\n\n  const text = selection.toString().trim();\n  if (!isValidText(text)) {\n    log.info(' Selected text is not valid for translation');\n    return;\n  }\n\n  const sanitized = sanitizeText(text);\n  log.info(' Translating selection:', sanitized.substring(0, 50) + '...');\n\n  try {\n    // Apply glossary pre-processing\n    const g = await loadGlossary();\n    const { processedText, restore } = await glossary.applyGlossary(sanitized, g);\n\n    const response = (await browserAPI.runtime.sendMessage({\n      type: 'translate',\n      text: processedText,\n      sourceLang,\n      targetLang,\n      options: { strategy },\n      provider,\n    })) as TranslateResponse;\n\n    if (response.success && response.result) {\n      // Apply glossary post-processing (restore placeholders)\n      const finalResult = restore(response.result as string);\n      showTranslationTooltip(finalResult, selection.getRangeAt(0));\n    } else {\n      log.error(' Translation failed:', response.error);\n      showErrorTooltip(response.error || 'Translation failed', selection.getRangeAt(0));\n    }\n  } catch (error) {\n    log.error(' Translation error:', error);\n    const message = error instanceof Error ? error.message : 'Unknown error';\n    showErrorTooltip(message, selection.getRangeAt(0));\n  }\n}\n\n/**\n * Translate entire page with batching and error handling\n */\nasync function translatePage(\n  sourceLang: string,\n  targetLang: string,\n  strategy: Strategy,\n  provider?: string,\n  enableProfiling = false\n): Promise<void> {\n  if (isTranslating) {\n    log.info(' Translation already in progress');\n    return;\n  }\n\n  isTranslating = true;\n  log.info(' Translating page...');\n  const pageStart = performance.now();\n\n  try {\n    // Time DOM scanning\n    const scanStart = performance.now();\n    const textNodes = getTextNodes(document.body);\n    const scanDuration = performance.now() - scanStart;\n    recordContentTiming('domScan', scanDuration);\n    console.log(`[Content] Found ${textNodes.length} text nodes in ${scanDuration.toFixed(2)}ms`);\n\n    if (textNodes.length === 0) {\n      log.info(' No translatable text found');\n      return;\n    }\n\n    // Time glossary loading\n    const glossaryStart = performance.now();\n    const g = await loadGlossary();\n    const glossaryDuration = performance.now() - glossaryStart;\n    recordContentTiming('glossaryApply', glossaryDuration);\n\n    // Create batches with length validation (prevent DoS from malicious pages)\n    const batches: Array<{ nodes: Text[]; texts: string[]; restoreFns: Array<(text: string) => string> }> = [];\n    for (let i = 0; i < textNodes.length; i += CONFIG.batching.maxSize) {\n      const batchNodes = textNodes.slice(i, i + CONFIG.batching.maxSize);\n      const rawTexts = batchNodes.map((n) => {\n        const text = sanitizeText(n.textContent || '');\n        // Enforce max length per text (defense against memory exhaustion)\n        return text.length > CONFIG.batching.maxTextLength\n          ? text.substring(0, CONFIG.batching.maxTextLength)\n          : text;\n      });\n\n      // Apply glossary to batch\n      const { processedTexts, restoreFns } = await glossary.applyGlossaryBatch(rawTexts, g);\n      batches.push({ nodes: batchNodes, texts: processedTexts, restoreFns });\n    }\n\n    console.log(`[Content] Processing ${batches.length} batches`);\n\n    let translatedCount = 0;\n    let errorCount = 0;\n    let totalIpcTime = 0;\n    let totalDomUpdateTime = 0;\n\n    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {\n      const batch = batches[batchIndex];\n\n      try {\n        // Time IPC roundtrip\n        const ipcStart = performance.now();\n        const response = (await browserAPI.runtime.sendMessage({\n          type: 'translate',\n          text: batch.texts,\n          sourceLang,\n          targetLang,\n          options: { strategy },\n          provider,\n          enableProfiling,\n        })) as TranslateResponse;\n        const ipcDuration = performance.now() - ipcStart;\n        totalIpcTime += ipcDuration;\n        recordContentTiming('ipcRoundtrip', ipcDuration);\n\n        if (response.success && Array.isArray(response.result)) {\n          // Time DOM updates\n          const domUpdateStart = performance.now();\n\n          // Replace text nodes with translations\n          response.result.forEach((translated, idx) => {\n            const node = batch.nodes[idx];\n            if (node && translated && node.parentElement) {\n              try {\n                // Apply glossary post-processing\n                const finalText = batch.restoreFns[idx](translated);\n\n                // Preserve whitespace\n                const original = node.textContent || '';\n                const leadingSpace = original.match(/^\\s*/)?.[0] || '';\n                const trailingSpace = original.match(/\\s*$/)?.[0] || '';\n\n                node.textContent = leadingSpace + finalText + trailingSpace;\n                node.parentElement.setAttribute(TRANSLATED_ATTR, 'true');\n                translatedCount++;\n              } catch {\n                // Node may have been removed from DOM\n                errorCount++;\n              }\n            }\n          });\n\n          const domUpdateDuration = performance.now() - domUpdateStart;\n          totalDomUpdateTime += domUpdateDuration;\n          recordContentTiming('domUpdate', domUpdateDuration);\n        } else {\n          console.error(`[Content] Batch ${batchIndex + 1} failed:`, response.error);\n          errorCount += batch.nodes.length;\n        }\n      } catch (error) {\n        console.error(`[Content] Batch ${batchIndex + 1} error:`, error);\n        errorCount += batch.nodes.length;\n      }\n    }\n\n    const totalTime = performance.now() - pageStart;\n    console.log(\n      `[Content] Page translation complete: ${translatedCount} translated, ${errorCount} errors\\n` +\n      `  Total: ${totalTime.toFixed(2)}ms\\n` +\n      `  DOM Scan: ${scanDuration.toFixed(2)}ms (${((scanDuration / totalTime) * 100).toFixed(1)}%)\\n` +\n      `  IPC Total: ${totalIpcTime.toFixed(2)}ms (${((totalIpcTime / totalTime) * 100).toFixed(1)}%)\\n` +\n      `  DOM Update: ${totalDomUpdateTime.toFixed(2)}ms (${((totalDomUpdateTime / totalTime) * 100).toFixed(1)}%)`\n    );\n\n    // Log content timing stats\n    if (enableProfiling) {\n      console.log('[Content] Timing Stats:', getContentTimingStats());\n    }\n  } finally {\n    isTranslating = false;\n  }\n}\n\n/**\n * Translate dynamically added content\n */\nasync function translateDynamicContent(nodes: Node[]): Promise<void> {\n  if (!currentSettings || isTranslating) return;\n\n  const textNodes = getTextNodesFromNodes(nodes);\n  if (textNodes.length === 0) return;\n\n  console.log(`[Content] Translating ${textNodes.length} dynamic text nodes`);\n\n  // Apply length validation (prevent DoS from malicious dynamic content)\n  const rawTexts = textNodes.map((n) => {\n    const text = sanitizeText(n.textContent || '');\n    return text.length > CONFIG.batching.maxTextLength\n      ? text.substring(0, CONFIG.batching.maxTextLength)\n      : text;\n  });\n\n  try {\n    // Apply glossary to batch\n    const g = await loadGlossary();\n    const { processedTexts, restoreFns } = await glossary.applyGlossaryBatch(rawTexts, g);\n\n    const response = (await browserAPI.runtime.sendMessage({\n      type: 'translate',\n      text: processedTexts,\n      sourceLang: currentSettings.sourceLang,\n      targetLang: currentSettings.targetLang,\n      options: { strategy: currentSettings.strategy },\n      provider: currentSettings.provider,\n    })) as TranslateResponse;\n\n    if (response.success && Array.isArray(response.result)) {\n      response.result.forEach((translated, idx) => {\n        const node = textNodes[idx];\n        if (node && translated && node.parentElement) {\n          try {\n            // Apply glossary post-processing\n            const finalText = restoreFns[idx](translated);\n\n            const original = node.textContent || '';\n            const leadingSpace = original.match(/^\\s*/)?.[0] || '';\n            const trailingSpace = original.match(/\\s*$/)?.[0] || '';\n\n            node.textContent = leadingSpace + finalText + trailingSpace;\n            node.parentElement.setAttribute(TRANSLATED_ATTR, 'true');\n          } catch {\n            // Ignore - node may have been removed\n          }\n        }\n      });\n    }\n  } catch (error) {\n    log.error(' Dynamic translation error:', error);\n  }\n}\n\n// ============================================================================\n// MutationObserver for Dynamic Content\n// ============================================================================\n\n/**\n * Process pending mutations with debouncing\n */\nfunction processPendingMutations(): void {\n  if (pendingMutations.length === 0) return;\n\n  // Collect all added nodes\n  const addedNodes: Node[] = [];\n  for (const mutation of pendingMutations) {\n    for (const node of mutation.addedNodes) {\n      if (\n        node.nodeType === Node.ELEMENT_NODE ||\n        node.nodeType === Node.TEXT_NODE\n      ) {\n        addedNodes.push(node);\n      }\n    }\n  }\n\n  pendingMutations = [];\n\n  if (addedNodes.length > 0) {\n    translateDynamicContent(addedNodes);\n  }\n}\n\n/**\n * Start observing DOM mutations for auto-translation\n */\nfunction startMutationObserver(): void {\n  if (mutationObserver) return;\n\n  mutationObserver = new MutationObserver((mutations) => {\n    // Add to pending mutations\n    for (const mutation of mutations) {\n      if (pendingMutations.length < CONFIG.mutations.maxPending) {\n        pendingMutations.push(mutation);\n      }\n    }\n\n    // Debounce processing\n    if (mutationDebounceTimer !== null) {\n      clearTimeout(mutationDebounceTimer);\n    }\n\n    mutationDebounceTimer = window.setTimeout(() => {\n      mutationDebounceTimer = null;\n      processPendingMutations();\n    }, CONFIG.mutations.debounceMs);\n  });\n\n  mutationObserver.observe(document.body, {\n    childList: true,\n    subtree: true,\n  });\n\n  log.info(' MutationObserver started');\n}\n\n/**\n * Stop observing DOM mutations\n */\nfunction stopMutationObserver(): void {\n  if (mutationObserver) {\n    mutationObserver.disconnect();\n    mutationObserver = null;\n  }\n\n  if (mutationDebounceTimer !== null) {\n    clearTimeout(mutationDebounceTimer);\n    mutationDebounceTimer = null;\n  }\n\n  pendingMutations = [];\n  log.info(' MutationObserver stopped');\n}\n\n// ============================================================================\n// UI Components\n// ============================================================================\n\n/**\n * Show translation tooltip\n */\nfunction showTranslationTooltip(text: string, range: Range): void {\n  removeTooltip();\n\n  const rect = range.getBoundingClientRect();\n\n  const tooltip = document.createElement('div');\n  tooltip.id = 'translate-tooltip';\n  tooltip.textContent = text;\n  tooltip.style.cssText = `\n    position: fixed;\n    top: ${Math.min(rect.bottom + 8, window.innerHeight - 100)}px;\n    left: ${Math.max(8, Math.min(rect.left, window.innerWidth - 416))}px;\n    max-width: 400px;\n    padding: 12px 16px;\n    background: #1e293b;\n    color: white;\n    border-radius: 8px;\n    font-size: 14px;\n    line-height: 1.5;\n    box-shadow: 0 10px 25px rgba(0,0,0,0.2);\n    z-index: 999999;\n    animation: translateFadeIn 0.2s ease;\n    word-wrap: break-word;\n  `;\n\n  // Add close button\n  const closeBtn = document.createElement('button');\n  closeBtn.innerHTML = '&times;';\n  closeBtn.style.cssText = `\n    position: absolute;\n    top: 4px;\n    right: 8px;\n    background: none;\n    border: none;\n    color: #94a3b8;\n    font-size: 18px;\n    cursor: pointer;\n    padding: 0;\n    line-height: 1;\n  `;\n  closeBtn.onclick = () => removeTooltip();\n  tooltip.appendChild(closeBtn);\n\n  document.body.appendChild(tooltip);\n\n  // Auto-remove after 10 seconds\n  setTimeout(() => removeTooltip(), 10000);\n}\n\n/**\n * Show error tooltip\n */\nfunction showErrorTooltip(message: string, range: Range): void {\n  removeTooltip();\n\n  const rect = range.getBoundingClientRect();\n\n  const tooltip = document.createElement('div');\n  tooltip.id = 'translate-tooltip';\n  tooltip.style.cssText = `\n    position: fixed;\n    top: ${Math.min(rect.bottom + 8, window.innerHeight - 100)}px;\n    left: ${Math.max(8, Math.min(rect.left, window.innerWidth - 416))}px;\n    max-width: 400px;\n    padding: 12px 16px;\n    background: #991b1b;\n    color: white;\n    border-radius: 8px;\n    font-size: 14px;\n    line-height: 1.5;\n    box-shadow: 0 10px 25px rgba(0,0,0,0.2);\n    z-index: 999999;\n    animation: translateFadeIn 0.2s ease;\n  `;\n\n  tooltip.textContent = message;\n\n  // Add close button\n  const closeBtn = document.createElement('button');\n  closeBtn.innerHTML = '&times;';\n  closeBtn.style.cssText = `\n    position: absolute;\n    top: 4px;\n    right: 8px;\n    background: none;\n    border: none;\n    color: #fca5a5;\n    font-size: 18px;\n    cursor: pointer;\n    padding: 0;\n    line-height: 1;\n  `;\n  closeBtn.onclick = () => removeTooltip();\n  tooltip.appendChild(closeBtn);\n\n  document.body.appendChild(tooltip);\n\n  // Auto-remove after 5 seconds\n  setTimeout(() => removeTooltip(), 5000);\n}\n\n/**\n * Remove tooltip\n */\nfunction removeTooltip(): void {\n  const existing = document.getElementById('translate-tooltip');\n  if (existing) existing.remove();\n}\n\n// Add animation styles\nconst style = document.createElement('style');\nstyle.textContent = `\n  @keyframes translateFadeIn {\n    from { opacity: 0; transform: translateY(-4px); }\n    to { opacity: 1; transform: translateY(0); }\n  }\n`;\ndocument.head.appendChild(style);\n\n// ============================================================================\n// Message Handling\n// ============================================================================\n\nbrowserAPI.runtime.onMessage.addListener(\n  (\n    message: ContentMessage,\n    _sender,\n    sendResponse: (response: boolean | { loaded: boolean }) => void\n  ) => {\n    if (message.type === 'ping') {\n      sendResponse({ loaded: true });\n      return true;\n    }\n\n    if (message.type === 'stopAutoTranslate') {\n      stopMutationObserver();\n      currentSettings = null;\n      sendResponse(true);\n      return true;\n    }\n\n    if (message.type === 'translateSelection') {\n      translateSelection(message.sourceLang, message.targetLang, message.strategy, message.provider)\n        .then(() => sendResponse(true))\n        .catch(() => sendResponse(false));\n      return true;\n    }\n\n    if (message.type === 'translatePage') {\n      // Store settings for dynamic content translation\n      currentSettings = {\n        sourceLang: message.sourceLang,\n        targetLang: message.targetLang,\n        strategy: message.strategy,\n        provider: message.provider,\n      };\n\n      translatePage(message.sourceLang, message.targetLang, message.strategy, message.provider)\n        .then(() => {\n          // Start observing for dynamic content\n          startMutationObserver();\n          sendResponse(true);\n        })\n        .catch(() => sendResponse(false));\n      return true;\n    }\n\n    return false;\n  }\n);\n\n// ============================================================================\n// Auto-Translate Check\n// ============================================================================\n\nasync function checkAutoTranslate(): Promise<void> {\n  // First check per-site rules\n  const hostname = window.location.hostname;\n  const siteSpecificRules = await siteRules.getRules(hostname);\n\n  // Get global settings as fallback\n  interface StoredSettings {\n    autoTranslate?: boolean;\n    sourceLang?: string;\n    targetLang?: string;\n    strategy?: Strategy;\n    provider?: TranslationProviderId;\n  }\n  const settings = await safeStorageGet<StoredSettings>([\n    'autoTranslate',\n    'sourceLang',\n    'targetLang',\n    'strategy',\n    'provider',\n  ]);\n\n  // Merge settings: site rules take precedence over global settings\n  const shouldAutoTranslate = siteSpecificRules?.autoTranslate ?? settings.autoTranslate;\n  const sourceLang = siteSpecificRules?.sourceLang || settings.sourceLang || 'auto';\n  const targetLang = siteSpecificRules?.targetLang || settings.targetLang || 'fi';\n  const strategy = siteSpecificRules?.strategy || settings.strategy || 'smart';\n  const provider = siteSpecificRules?.preferredProvider || settings.provider || 'opus-mt';\n\n  if (siteSpecificRules) {\n    log.info(' Site-specific rules found for', hostname, siteSpecificRules);\n  }\n\n  if (shouldAutoTranslate) {\n    log.info(' Auto-translate enabled, translating page...');\n\n    currentSettings = {\n      sourceLang,\n      targetLang,\n      strategy: strategy as Strategy,\n      provider: provider as TranslationProviderId,\n    };\n\n    // Small delay to let page settle\n    setTimeout(() => {\n      translatePage(\n        currentSettings!.sourceLang,\n        currentSettings!.targetLang,\n        currentSettings!.strategy,\n        currentSettings!.provider\n      ).then(() => {\n        startMutationObserver();\n      });\n    }, 1000);\n  }\n}\n\n// Run auto-translate check on load\nif (document.readyState === 'complete') {\n  checkAutoTranslate();\n} else {\n  window.addEventListener('load', checkAutoTranslate);\n}\n\n// Cleanup on unload\nwindow.addEventListener('unload', () => {\n  stopMutationObserver();\n});\n\nlog.info(' Translation content script loaded v2.3 with MutationObserver + site rules + glossary support');\n"],"names":["log","createLogger","contentTimings","recordContentTiming","category","durationMs","arr","getContentTimingStats","result","key","sum","a","b","SKIP_TAGS","TRANSLATED_ATTR","isTranslating","pendingMutations","mutationDebounceTimer","mutationObserver","currentSettings","cachedGlossary","shouldSkip","element","style","isValidText","text","trimmed","CONFIG","sanitizeText","getTextNodes","root","nodes","walker","node","parent","getTextNodesFromNodes","textNodes","loadGlossary","glossary","e","translateSelection","sourceLang","targetLang","strategy","provider","selection","sanitized","g","processedText","restore","response","browserAPI","finalResult","showTranslationTooltip","showErrorTooltip","error","message","translatePage","enableProfiling","pageStart","scanStart","scanDuration","glossaryStart","glossaryDuration","batches","i","batchNodes","rawTexts","n","processedTexts","restoreFns","translatedCount","errorCount","totalIpcTime","totalDomUpdateTime","batchIndex","batch","ipcStart","ipcDuration","domUpdateStart","translated","idx","finalText","original","leadingSpace","trailingSpace","domUpdateDuration","totalTime","translateDynamicContent","processPendingMutations","addedNodes","mutation","startMutationObserver","mutations","stopMutationObserver","range","removeTooltip","rect","tooltip","closeBtn","existing","_sender","sendResponse","checkAutoTranslate","hostname","siteSpecificRules","siteRules","settings","safeStorageGet","shouldAutoTranslate"],"mappings":"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"}