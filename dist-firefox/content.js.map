{"version":3,"file":"content.js","sources":["../src/core/logger.ts","../src/core/site-rules.ts","../src/core/glossary.ts","../src/config.ts","../src/core/browser-api.ts","../src/core/storage.ts","../src/content/index.ts"],"sourcesContent":["/**\n * Simple logging utility with module prefixing\n */\n\nexport function createLogger(module: string) {\n  return {\n    debug: (msg: string, ...args: unknown[]) => console.log(`[${module}]`, msg, ...args),\n    info: (msg: string, ...args: unknown[]) => console.log(`[${module}]`, msg, ...args),\n    warn: (msg: string, ...args: unknown[]) => console.warn(`[${module}]`, msg, ...args),\n    error: (msg: string, ...args: unknown[]) => console.error(`[${module}]`, msg, ...args),\n  };\n}\n","/**\n * Per-site translation rules\n * Stores and retrieves site-specific translation preferences\n *\n * Features:\n * - Per-hostname preferences (auto-translate, provider, languages)\n * - Wildcard matching (*.example.com)\n * - Persistent storage via chrome.storage.local\n */\n\nimport type { TranslationProviderId, Strategy } from '../types';\nimport { createLogger } from './logger';\n\nconst log = createLogger('SiteRules');\n\nexport interface SiteRules {\n  autoTranslate: boolean;\n  preferredProvider?: TranslationProviderId;\n  sourceLang?: string;\n  targetLang?: string;\n  strategy?: Strategy;\n}\n\nexport interface SiteRulesStore {\n  [hostname: string]: SiteRules;\n}\n\nconst STORAGE_KEY = 'siteRules';\n\n/**\n * Check if hostname matches a wildcard pattern\n * Supports patterns like *.example.com\n */\nexport function matchesPattern(hostname: string, pattern: string): boolean {\n  if (pattern === hostname) {\n    return true;\n  }\n\n  // Handle wildcard patterns\n  if (pattern.startsWith('*.')) {\n    const baseDomain = pattern.slice(2);\n    // Match exact domain or any subdomain\n    return hostname === baseDomain || hostname.endsWith('.' + baseDomain);\n  }\n\n  return false;\n}\n\n/**\n * Find the best matching rule for a hostname\n * Exact matches take precedence over wildcard matches\n */\nexport function findMatchingRule(\n  hostname: string,\n  rules: SiteRulesStore\n): { pattern: string; rules: SiteRules } | null {\n  // First check for exact match\n  if (rules[hostname]) {\n    return { pattern: hostname, rules: rules[hostname] };\n  }\n\n  // Then check wildcard patterns (sorted by specificity)\n  const wildcardPatterns = Object.keys(rules)\n    .filter((pattern) => pattern.startsWith('*.'))\n    .sort((a, b) => b.length - a.length); // More specific patterns first\n\n  for (const pattern of wildcardPatterns) {\n    if (matchesPattern(hostname, pattern)) {\n      return { pattern, rules: rules[pattern] };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get site rules for a hostname\n * Returns matching rules considering wildcard patterns\n */\nexport async function getRules(hostname: string): Promise<SiteRules | null> {\n  try {\n    const data = await chrome.storage.local.get(STORAGE_KEY);\n    const allRules: SiteRulesStore = data[STORAGE_KEY] || {};\n\n    const match = findMatchingRule(hostname, allRules);\n    return match ? match.rules : null;\n  } catch (e) {\n    log.error(' Failed to get rules:', e);\n    return null;\n  }\n}\n\n/**\n * Set site rules for a specific hostname or pattern\n */\nexport async function setRules(hostnameOrPattern: string, rules: SiteRules): Promise<void> {\n  try {\n    const data = await chrome.storage.local.get(STORAGE_KEY);\n    const allRules: SiteRulesStore = data[STORAGE_KEY] || {};\n\n    allRules[hostnameOrPattern] = rules;\n\n    await chrome.storage.local.set({ [STORAGE_KEY]: allRules });\n    log.info(' Updated rules for:', hostnameOrPattern, rules);\n  } catch (e) {\n    log.error(' Failed to set rules:', e);\n    throw e;\n  }\n}\n\n/**\n * Clear site rules for a specific hostname or pattern\n */\nexport async function clearRules(hostnameOrPattern: string): Promise<void> {\n  try {\n    const data = await chrome.storage.local.get(STORAGE_KEY);\n    const allRules: SiteRulesStore = data[STORAGE_KEY] || {};\n\n    delete allRules[hostnameOrPattern];\n\n    await chrome.storage.local.set({ [STORAGE_KEY]: allRules });\n    log.info(' Cleared rules for:', hostnameOrPattern);\n  } catch (e) {\n    log.error(' Failed to clear rules:', e);\n    throw e;\n  }\n}\n\n/**\n * Get all site rules\n */\nexport async function getAllRules(): Promise<SiteRulesStore> {\n  try {\n    const data = await chrome.storage.local.get(STORAGE_KEY);\n    return data[STORAGE_KEY] || {};\n  } catch (e) {\n    log.error(' Failed to get all rules:', e);\n    return {};\n  }\n}\n\n/**\n * Clear all site rules\n */\nexport async function clearAllRules(): Promise<void> {\n  try {\n    await chrome.storage.local.remove(STORAGE_KEY);\n    log.info(' Cleared all rules');\n  } catch (e) {\n    log.error(' Failed to clear all rules:', e);\n    throw e;\n  }\n}\n\n/**\n * Export rules as JSON string\n */\nexport async function exportRules(): Promise<string> {\n  const rules = await getAllRules();\n  return JSON.stringify(rules, null, 2);\n}\n\n/**\n * Import rules from JSON string\n * Merges with existing rules (imported rules take precedence)\n */\nexport async function importRules(json: string): Promise<number> {\n  try {\n    const imported: SiteRulesStore = JSON.parse(json);\n\n    // Validate structure\n    for (const [hostname, rules] of Object.entries(imported)) {\n      if (typeof hostname !== 'string') {\n        throw new Error(`Invalid hostname: ${hostname}`);\n      }\n      if (typeof rules !== 'object' || rules === null) {\n        throw new Error(`Invalid rules for ${hostname}`);\n      }\n      if (typeof rules.autoTranslate !== 'boolean') {\n        throw new Error(`Invalid autoTranslate for ${hostname}`);\n      }\n    }\n\n    const existing = await getAllRules();\n    const merged = { ...existing, ...imported };\n\n    await chrome.storage.local.set({ [STORAGE_KEY]: merged });\n    log.info(' Imported', Object.keys(imported).length, 'rules');\n\n    return Object.keys(imported).length;\n  } catch (e) {\n    log.error(' Failed to import rules:', e);\n    throw e;\n  }\n}\n\nexport const siteRules = {\n  getRules,\n  setRules,\n  clearRules,\n  getAllRules,\n  clearAllRules,\n  exportRules,\n  importRules,\n  matchesPattern,\n  findMatchingRule,\n};\n\nexport default siteRules;\n","/**\n * Glossary - Custom term replacements for translations\n *\n * Features:\n * - Pre-processing: Replace terms before sending to translator\n * - Post-processing: Restore placeholder-protected terms after translation\n * - Case sensitivity options\n * - Import/export as JSON\n */\n\nimport { createLogger } from './logger';\n\nconst log = createLogger('Glossary');\n\nexport interface GlossaryTerm {\n  replacement: string;\n  caseSensitive: boolean;\n  description?: string;\n}\n\nexport interface GlossaryStore {\n  [term: string]: GlossaryTerm;\n}\n\n// Placeholder format for protecting terms during translation\nconst PLACEHOLDER_PREFIX = '\\u200B\\u2063TERM_';\nconst PLACEHOLDER_SUFFIX = '\\u2063\\u200B';\n\nconst STORAGE_KEY = 'glossary';\n\n/**\n * Get the entire glossary\n */\nexport async function getGlossary(): Promise<GlossaryStore> {\n  try {\n    const data = await chrome.storage.local.get(STORAGE_KEY);\n    return data[STORAGE_KEY] || {};\n  } catch (e) {\n    log.error(' Failed to get glossary:', e);\n    return {};\n  }\n}\n\n/**\n * Add or update a glossary term\n */\nexport async function addTerm(\n  term: string,\n  replacement: string,\n  caseSensitive = false,\n  description?: string\n): Promise<void> {\n  if (!term || !replacement) {\n    throw new Error('Term and replacement are required');\n  }\n\n  try {\n    const glossary = await getGlossary();\n    glossary[term] = { replacement, caseSensitive, description };\n    await chrome.storage.local.set({ [STORAGE_KEY]: glossary });\n    log.info(' Added term:', term, '->', replacement);\n  } catch (e) {\n    log.error(' Failed to add term:', e);\n    throw e;\n  }\n}\n\n/**\n * Remove a glossary term\n */\nexport async function removeTerm(term: string): Promise<void> {\n  try {\n    const glossary = await getGlossary();\n    delete glossary[term];\n    await chrome.storage.local.set({ [STORAGE_KEY]: glossary });\n    log.info(' Removed term:', term);\n  } catch (e) {\n    log.error(' Failed to remove term:', e);\n    throw e;\n  }\n}\n\n/**\n * Clear all glossary terms\n */\nexport async function clearGlossary(): Promise<void> {\n  try {\n    await chrome.storage.local.remove(STORAGE_KEY);\n    log.info(' Cleared glossary');\n  } catch (e) {\n    log.error(' Failed to clear glossary:', e);\n    throw e;\n  }\n}\n\n/**\n * Create a regex for matching a term (with case sensitivity)\n */\nfunction createTermRegex(term: string, caseSensitive: boolean): RegExp {\n  // Escape special regex characters\n  const escaped = term.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  // Word boundary matching\n  return new RegExp(`\\\\b${escaped}\\\\b`, caseSensitive ? 'g' : 'gi');\n}\n\n/**\n * Apply glossary pre-processing to text before translation\n * Replaces terms with their target replacements\n *\n * @param text - Text to process\n * @param glossary - Glossary terms to apply\n * @returns Processed text with replacements\n */\nexport function applyGlossaryPreProcess(text: string, glossary: GlossaryStore): string {\n  let result = text;\n\n  // Sort terms by length (longest first) to avoid partial matches\n  const sortedTerms = Object.keys(glossary).sort((a, b) => b.length - a.length);\n\n  for (const term of sortedTerms) {\n    const entry = glossary[term];\n    const regex = createTermRegex(term, entry.caseSensitive);\n    result = result.replace(regex, entry.replacement);\n  }\n\n  return result;\n}\n\n/**\n * Apply glossary with placeholder protection\n * Replaces terms with placeholders that survive translation\n *\n * @param text - Text to process\n * @param glossary - Glossary terms to apply\n * @returns Object with processed text and placeholder map for restoration\n */\nexport function applyGlossaryWithPlaceholders(\n  text: string,\n  glossary: GlossaryStore\n): { text: string; placeholderMap: Map<string, string> } {\n  let result = text;\n  const placeholderMap = new Map<string, string>();\n  let placeholderIndex = 0;\n\n  // Sort terms by length (longest first) to avoid partial matches\n  const sortedTerms = Object.keys(glossary).sort((a, b) => b.length - a.length);\n\n  for (const term of sortedTerms) {\n    const entry = glossary[term];\n    const regex = createTermRegex(term, entry.caseSensitive);\n\n    result = result.replace(regex, () => {\n      const placeholder = `${PLACEHOLDER_PREFIX}${placeholderIndex}${PLACEHOLDER_SUFFIX}`;\n      placeholderMap.set(placeholder, entry.replacement);\n      placeholderIndex++;\n      return placeholder;\n    });\n  }\n\n  return { text: result, placeholderMap };\n}\n\n/**\n * Restore placeholders with their actual replacements\n *\n * @param text - Translated text with placeholders\n * @param placeholderMap - Map of placeholders to replacements\n * @returns Text with placeholders replaced by actual terms\n */\nexport function restorePlaceholders(text: string, placeholderMap: Map<string, string>): string {\n  let result = text;\n\n  for (const [placeholder, replacement] of placeholderMap) {\n    result = result.split(placeholder).join(replacement);\n  }\n\n  return result;\n}\n\n/**\n * Convenience function: Apply glossary to text for translation\n * Uses placeholder method for protection during translation\n *\n * @param text - Original text\n * @param glossary - Glossary to apply (optional, will load from storage if not provided)\n * @returns Object with processed text and restore function\n */\nexport async function applyGlossary(\n  text: string,\n  glossary?: GlossaryStore\n): Promise<{ processedText: string; restore: (translated: string) => string }> {\n  const g = glossary ?? (await getGlossary());\n\n  if (Object.keys(g).length === 0) {\n    return { processedText: text, restore: (t) => t };\n  }\n\n  const { text: processedText, placeholderMap } = applyGlossaryWithPlaceholders(text, g);\n\n  return {\n    processedText,\n    restore: (translated: string) => restorePlaceholders(translated, placeholderMap),\n  };\n}\n\n/**\n * Apply glossary to an array of texts\n */\nexport async function applyGlossaryBatch(\n  texts: string[],\n  glossary?: GlossaryStore\n): Promise<{ processedTexts: string[]; restoreFns: Array<(text: string) => string> }> {\n  const g = glossary ?? (await getGlossary());\n\n  if (Object.keys(g).length === 0) {\n    return { processedTexts: texts, restoreFns: texts.map(() => (t: string) => t) };\n  }\n\n  const results = texts.map((text) => {\n    const { text: processedText, placeholderMap } = applyGlossaryWithPlaceholders(text, g);\n    return {\n      processedText,\n      restore: (translated: string) => restorePlaceholders(translated, placeholderMap),\n    };\n  });\n\n  return {\n    processedTexts: results.map((r) => r.processedText),\n    restoreFns: results.map((r) => r.restore),\n  };\n}\n\n/**\n * Export glossary as JSON string\n */\nexport async function exportGlossary(): Promise<string> {\n  const glossary = await getGlossary();\n  return JSON.stringify(glossary, null, 2);\n}\n\n/**\n * Import glossary from JSON string\n * Merges with existing glossary (imported terms take precedence)\n */\nexport async function importGlossary(json: string): Promise<number> {\n  try {\n    const imported: GlossaryStore = JSON.parse(json);\n\n    // Validate structure\n    for (const [term, entry] of Object.entries(imported)) {\n      if (typeof term !== 'string') {\n        throw new Error(`Invalid term: ${term}`);\n      }\n      if (typeof entry !== 'object' || entry === null) {\n        throw new Error(`Invalid entry for term: ${term}`);\n      }\n      if (typeof entry.replacement !== 'string') {\n        throw new Error(`Invalid replacement for term: ${term}`);\n      }\n      if (typeof entry.caseSensitive !== 'boolean') {\n        throw new Error(`Invalid caseSensitive for term: ${term}`);\n      }\n    }\n\n    const existing = await getGlossary();\n    const merged = { ...existing, ...imported };\n\n    await chrome.storage.local.set({ [STORAGE_KEY]: merged });\n    log.info(' Imported', Object.keys(imported).length, 'terms');\n\n    return Object.keys(imported).length;\n  } catch (e) {\n    log.error(' Failed to import glossary:', e);\n    throw e;\n  }\n}\n\nexport const glossary = {\n  getGlossary,\n  addTerm,\n  removeTerm,\n  clearGlossary,\n  applyGlossary,\n  applyGlossaryBatch,\n  applyGlossaryPreProcess,\n  applyGlossaryWithPlaceholders,\n  restorePlaceholders,\n  exportGlossary,\n  importGlossary,\n};\n\nexport default glossary;\n","/**\n * Centralized configuration constants for the extension.\n * All hardcoded values extracted here for maintainability.\n */\n\nexport const CONFIG = {\n  /**\n   * Translation cache settings (persistent LRU cache in service worker)\n   */\n  cache: {\n    /** Maximum number of cached translations */\n    maxSize: 1000,\n    /** Storage key for persistent cache */\n    storageKey: 'translationMemory',\n    /** Debounce delay for saving cache to storage (ms) */\n    saveDebounceMs: 5000,\n  },\n\n  /**\n   * Timeout settings for various operations.\n   * Split by model size to avoid UI blocking for smaller models.\n   */\n  timeouts: {\n    /** OPUS-MT direct model loading timeout (60s for ~170MB models) */\n    opusMtDirectMs: 60 * 1000,\n    /** OPUS-MT pivot model loading timeout (120s for 2 × ~170MB models) */\n    opusMtPivotMs: 2 * 60 * 1000,\n    /** TranslateGemma model loading timeout (5 minutes for ~3.6GB model) */\n    translateGemmaMs: 5 * 60 * 1000,\n    /** Legacy: default model loading timeout (kept for backward compatibility) */\n    modelLoadMs: 2 * 60 * 1000,\n    /** Offscreen document communication timeout */\n    offscreenMs: 2 * 60 * 1000,\n  },\n\n  /**\n   * Rate limiting configuration\n   */\n  rateLimits: {\n    /** Maximum requests per window */\n    requestsPerMinute: 60,\n    /** Maximum tokens per window */\n    tokensPerMinute: 100000,\n    /** Rate limit window duration */\n    windowMs: 60000,\n  },\n\n  /**\n   * Batching configuration for page translation\n   */\n  batching: {\n    /** Maximum texts per batch */\n    maxSize: 50,\n    /** Maximum text length for translation */\n    maxTextLength: 5000,\n    /** Minimum text length for translation */\n    minTextLength: 2,\n  },\n\n  /**\n   * Retry configuration for network operations\n   */\n  retry: {\n    /** Network retry settings */\n    network: {\n      maxRetries: 3,\n      baseDelayMs: 1000,\n      maxDelayMs: 10000,\n    },\n    /** Offscreen document retry settings */\n    offscreen: {\n      maxRetries: 2,\n      baseDelayMs: 500,\n      maxDelayMs: 3000,\n    },\n    /** Maximum offscreen document creation failures before hard error */\n    maxOffscreenFailures: 3,\n  },\n\n  /**\n   * Mutation observer throttling for dynamic content\n   */\n  mutations: {\n    /** Debounce delay for processing mutations */\n    debounceMs: 500,\n    /** Maximum pending mutations to buffer (high for content-heavy pages like Dutch news sites) */\n    maxPending: 500,\n  },\n\n  /**\n   * Throttle defaults (used by Throttle class)\n   */\n  throttle: {\n    requestLimit: 60,\n    tokenLimit: 100000,\n    windowMs: 60000,\n  },\n} as const;\n\n/**\n * Type for accessing nested config values\n */\nexport type Config = typeof CONFIG;\n","/**\n * Browser API Compatibility Layer\n *\n * Provides a unified API that works across Chrome, Firefox, and Edge.\n * Firefox uses the Promise-based browser.* API natively.\n * Chrome uses the callback-based chrome.* API (with Promise wrappers in newer versions).\n *\n * This module exports a `browserAPI` object that normalizes these differences.\n */\n\n// Type declaration for browser.* (Firefox WebExtension API)\ndeclare const browser: typeof chrome | undefined;\n\n/**\n * Get the appropriate browser API object.\n * Firefox exposes `browser`, Chrome/Edge expose `chrome`.\n * Modern Chrome also supports `chrome` with Promises, so we prefer `browser` if available\n * as it's guaranteed to be Promise-based.\n */\nexport const browserAPI: typeof chrome =\n  typeof browser !== 'undefined' ? browser : chrome;\n\n/**\n * Check if running in Firefox\n */\nexport function isFirefox(): boolean {\n  return typeof browser !== 'undefined' && navigator.userAgent.includes('Firefox');\n}\n\n/**\n * Check if running in Chrome/Chromium\n */\nexport function isChrome(): boolean {\n  return typeof chrome !== 'undefined' && !isFirefox();\n}\n\n/**\n * Get extension URL for a resource\n */\nexport function getURL(path: string): string {\n  return browserAPI.runtime.getURL(path);\n}\n\n/**\n * Send a message to the background script\n */\nexport function sendMessage<T = unknown>(message: unknown): Promise<T> {\n  return browserAPI.runtime.sendMessage(message);\n}\n\n/**\n * Listen for messages\n */\nexport function onMessage(\n  callback: (\n    message: unknown,\n    sender: chrome.runtime.MessageSender,\n    sendResponse: (response?: unknown) => void\n  ) => boolean | void | Promise<unknown>\n): void {\n  browserAPI.runtime.onMessage.addListener(callback);\n}\n\n/**\n * Storage API wrappers (local storage)\n */\nexport const storage = {\n  async get<T = Record<string, unknown>>(keys: string | string[]): Promise<T> {\n    return browserAPI.storage.local.get(keys) as Promise<T>;\n  },\n\n  async set(items: Record<string, unknown>): Promise<void> {\n    return browserAPI.storage.local.set(items);\n  },\n\n  async remove(keys: string | string[]): Promise<void> {\n    return browserAPI.storage.local.remove(keys);\n  },\n\n  async clear(): Promise<void> {\n    return browserAPI.storage.local.clear();\n  },\n};\n\n/**\n * Get the current platform (for debugging)\n */\nexport function getPlatform(): 'firefox' | 'chrome' | 'edge' | 'unknown' {\n  const ua = navigator.userAgent;\n  if (ua.includes('Firefox')) return 'firefox';\n  if (ua.includes('Edg/')) return 'edge';\n  if (ua.includes('Chrome')) return 'chrome';\n  return 'unknown';\n}\n","import { createLogger } from './logger';\nimport { browserAPI } from './browser-api';\n\nconst log = createLogger('Storage');\n\nexport async function safeStorageGet<T>(keys: string | string[]): Promise<Partial<T>> {\n  try {\n    return await browserAPI.storage.local.get(keys) as Partial<T>;\n  } catch (error) {\n    log.warn('Storage get failed:', error);\n    return {};\n  }\n}\n\nexport async function safeStorageSet(items: Record<string, unknown>): Promise<boolean> {\n  try {\n    await browserAPI.storage.local.set(items);\n    return true;\n  } catch (error) {\n    log.warn('Storage set failed:', error);\n    return false;\n  }\n}\n","/**\n * Content Script\n * Handles DOM scanning and text replacement for translations\n *\n * Features:\n * - MutationObserver for dynamic content\n * - Graceful degradation on translation failures\n * - Skip untranslatable elements (scripts, styles, inputs)\n * - Throttled translation to prevent rate limiting\n * - Per-site rules for automatic translation preferences\n * - Glossary support for custom term replacements\n */\n\nimport type { Strategy, TranslationProviderId, TranslateResponse } from '../types';\nimport { siteRules } from '../core/site-rules';\nimport { glossary, type GlossaryStore } from '../core/glossary';\nimport { CONFIG } from '../config';\nimport { createLogger } from '../core/logger';\nimport { safeStorageGet } from '../core/storage';\nimport { browserAPI } from '../core/browser-api';\n// measureTimeAsync imported for future use in async profiling\n// import { measureTimeAsync } from '../core/profiler';\n\nconst log = createLogger('Content');\n\n// Simple content-script timing tracker (separate from background profiler)\n// Uses pre-allocated circular buffers instead of shift() which is O(n).\nconst TIMING_BUFFER_SIZE = 100;\n\nclass CircularTimingBuffer {\n  private buffer: Float64Array;\n  private writeIndex = 0;\n  private count = 0;\n\n  constructor(size: number) {\n    this.buffer = new Float64Array(size);\n  }\n\n  push(value: number): void {\n    this.buffer[this.writeIndex] = value;\n    this.writeIndex = (this.writeIndex + 1) % this.buffer.length;\n    if (this.count < this.buffer.length) this.count++;\n  }\n\n  getStats(): { avg: number; min: number; max: number; count: number } | null {\n    if (this.count === 0) return null;\n    let sum = 0, min = Infinity, max = -Infinity;\n    for (let i = 0; i < this.count; i++) {\n      const val = this.buffer[i];\n      sum += val;\n      if (val < min) min = val;\n      if (val > max) max = val;\n    }\n    return { avg: sum / this.count, min, max, count: this.count };\n  }\n}\n\nconst contentTimings = {\n  domScan: new CircularTimingBuffer(TIMING_BUFFER_SIZE),\n  domUpdate: new CircularTimingBuffer(TIMING_BUFFER_SIZE),\n  glossaryApply: new CircularTimingBuffer(TIMING_BUFFER_SIZE),\n  ipcRoundtrip: new CircularTimingBuffer(TIMING_BUFFER_SIZE),\n};\n\nfunction recordContentTiming(category: keyof typeof contentTimings, durationMs: number): void {\n  contentTimings[category].push(durationMs);\n}\n\nfunction getContentTimingStats(): Record<string, { avg: number; min: number; max: number; count: number }> {\n  const result: Record<string, { avg: number; min: number; max: number; count: number }> = {};\n  for (const [key, buffer] of Object.entries(contentTimings)) {\n    const stats = buffer.getStats();\n    if (stats) result[key] = stats;\n  }\n  return result;\n}\n\n// Content-script specific message types (extend base types)\ninterface TranslateSelectionMessage {\n  type: 'translateSelection';\n  sourceLang: string;\n  targetLang: string;\n  strategy: Strategy;\n  provider?: string;\n}\n\ninterface TranslatePageMessage {\n  type: 'translatePage';\n  sourceLang: string;\n  targetLang: string;\n  strategy: Strategy;\n  provider?: string;\n}\n\ninterface TranslateImageMessage {\n  type: 'translateImage';\n  imageUrl: string;\n  sourceLang: string;\n  targetLang: string;\n  provider?: string;\n}\n\ntype ContentMessage =\n  | TranslateSelectionMessage\n  | TranslatePageMessage\n  | TranslateImageMessage\n  | { type: 'ping' }\n  | { type: 'stopAutoTranslate' }\n  | { type: 'undoTranslation' }\n  | { type: 'toggleBilingualMode' }\n  | { type: 'setBilingualMode'; enabled: boolean }\n  | { type: 'getBilingualMode' }\n  | { type: 'toggleWidget' }\n  | { type: 'showWidget' };\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n// Elements to skip during translation\nconst SKIP_TAGS = new Set([\n  'SCRIPT',\n  'STYLE',\n  'NOSCRIPT',\n  'TEMPLATE',\n  'CODE',\n  'PRE',\n  'TEXTAREA',\n  'INPUT',\n  'SELECT',\n  'BUTTON',\n  'SVG',\n  'MATH',\n  'CANVAS',\n  'VIDEO',\n  'AUDIO',\n  'IFRAME',\n  'OBJECT',\n  'EMBED',\n]);\n\n// Mark translated nodes to avoid re-translation\nconst TRANSLATED_ATTR = 'data-translated';\n\n// Attribute to store original text for undo\nconst ORIGINAL_TEXT_ATTR = 'data-original-text';\n\n// Attributes for correction learning\nconst MACHINE_TRANSLATION_ATTR = 'data-machine-translation';\nconst SOURCE_LANG_ATTR = 'data-source-lang';\nconst TARGET_LANG_ATTR = 'data-target-lang';\n\n// ============================================================================\n// State\n// ============================================================================\n\nlet isTranslatingPage = false;\nlet isTranslatingDynamic = false;\nlet pendingMutations: MutationRecord[] = [];\nlet mutationDebounceTimer: number | null = null;\nlet mutationObserver: MutationObserver | null = null;\n/** Queued dynamic nodes that arrived during page translation, translated after page completes */\nlet queuedDynamicNodes: Node[] = [];\n\n// WeakMap cache for shouldSkip results — avoids redundant getComputedStyle\n// across text nodes sharing the same parent element. Auto-GC'd when elements detach.\nconst skipCache = new WeakMap<Element, boolean>();\nlet currentSettings: {\n  sourceLang: string;\n  targetLang: string;\n  strategy: Strategy;\n  provider?: string;\n} | null = null;\n\n// Cache for glossary terms (loaded once per page)\nlet cachedGlossary: GlossaryStore | null = null;\n\n// ============================================================================\n// Toast Notifications\n// ============================================================================\n\n/** Active progress toast reference (for live updates during translation) */\nlet activeProgressToast: HTMLElement | null = null;\n\n/**\n * Show a brief info toast message to the user\n */\nfunction showInfoToast(message: string, durationMs = 3000): void {\n  // Remove any existing toast (but not an active progress toast mid-translation)\n  const existing = document.getElementById('translate-ext-toast');\n  if (existing && existing !== activeProgressToast) existing.remove();\n\n  const toast = document.createElement('div');\n  toast.id = 'translate-ext-toast';\n  toast.textContent = message;\n  Object.assign(toast.style, {\n    position: 'fixed',\n    bottom: '20px',\n    left: '50%',\n    transform: 'translateX(-50%)',\n    background: '#1e293b',\n    color: '#f1f5f9',\n    padding: '12px 20px',\n    borderRadius: '8px',\n    fontSize: '14px',\n    fontFamily: 'system-ui, -apple-system, sans-serif',\n    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',\n    zIndex: '2147483647',\n    opacity: '0',\n    transition: 'opacity 0.2s ease',\n  });\n\n  document.body.appendChild(toast);\n\n  // Fade in\n  requestAnimationFrame(() => {\n    toast.style.opacity = '1';\n  });\n\n  // Fade out and remove\n  setTimeout(() => {\n    toast.style.opacity = '0';\n    setTimeout(() => toast.remove(), 200);\n  }, durationMs);\n}\n\n/**\n * Show a persistent progress toast that updates in-place during translation.\n * Returns the toast element for live updates. Call removeProgressToast() when done.\n */\nfunction showProgressToast(message: string): HTMLElement {\n  // Remove previous progress toast\n  removeProgressToast();\n\n  const toast = document.createElement('div');\n  toast.id = 'translate-ext-progress-toast';\n  Object.assign(toast.style, {\n    position: 'fixed',\n    bottom: '20px',\n    left: '50%',\n    transform: 'translateX(-50%)',\n    background: '#1e293b',\n    color: '#f1f5f9',\n    padding: '12px 20px',\n    borderRadius: '8px',\n    fontSize: '14px',\n    fontFamily: 'system-ui, -apple-system, sans-serif',\n    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',\n    zIndex: '2147483647',\n    opacity: '0',\n    transition: 'opacity 0.2s ease',\n    display: 'flex',\n    alignItems: 'center',\n    gap: '10px',\n    minWidth: '200px',\n  });\n\n  // Spinner + message + progress bar\n  toast.innerHTML = `\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"flex-shrink: 0; animation: translate-spin 1s linear infinite;\">\n      <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" stroke-width=\"2\" stroke-dasharray=\"31.4 31.4\" stroke-linecap=\"round\"/>\n    </svg>\n    <span class=\"translate-progress-text\">${message}</span>\n    <style>\n      @keyframes translate-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }\n    </style>\n  `;\n\n  document.body.appendChild(toast);\n  activeProgressToast = toast;\n\n  requestAnimationFrame(() => {\n    toast.style.opacity = '1';\n  });\n\n  return toast;\n}\n\n/**\n * Update the text of the active progress toast\n */\nfunction updateProgressToast(message: string): void {\n  if (!activeProgressToast) return;\n  const textEl = activeProgressToast.querySelector('.translate-progress-text');\n  if (textEl) textEl.textContent = message;\n}\n\n/**\n * Remove the progress toast with a fade-out\n */\nfunction removeProgressToast(): void {\n  if (activeProgressToast) {\n    const toast = activeProgressToast;\n    activeProgressToast = null;\n    toast.style.opacity = '0';\n    setTimeout(() => toast.remove(), 200);\n  }\n  // Also remove by ID in case reference was lost\n  const existing = document.getElementById('translate-ext-progress-toast');\n  if (existing) {\n    existing.style.opacity = '0';\n    setTimeout(() => existing.remove(), 200);\n  }\n}\n\n/**\n * Show an error toast message to the user\n */\nfunction showErrorToast(message: string, durationMs = 6000): void {\n  // Remove any existing toast\n  const existing = document.getElementById('translate-ext-toast');\n  if (existing) existing.remove();\n\n  const toast = document.createElement('div');\n  toast.id = 'translate-ext-toast';\n  Object.assign(toast.style, {\n    position: 'fixed',\n    bottom: '20px',\n    left: '50%',\n    transform: 'translateX(-50%)',\n    background: '#991b1b',\n    color: '#fef2f2',\n    padding: '12px 20px',\n    borderRadius: '8px',\n    fontSize: '14px',\n    fontFamily: 'system-ui, -apple-system, sans-serif',\n    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.25)',\n    zIndex: '2147483647',\n    opacity: '0',\n    transition: 'opacity 0.2s ease',\n    maxWidth: '400px',\n    textAlign: 'center',\n    lineHeight: '1.4',\n  });\n\n  // Add icon and message (use textContent for message to prevent XSS)\n  const wrapper = document.createElement('div');\n  Object.assign(wrapper.style, { display: 'flex', alignItems: 'flex-start', gap: '10px' });\n  wrapper.innerHTML = `\n    <svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"flex-shrink: 0; margin-top: 2px;\">\n      <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" stroke-width=\"2\"/>\n      <line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n      <circle cx=\"12\" cy=\"16\" r=\"1\" fill=\"currentColor\"/>\n    </svg>\n  `;\n  const msgSpan = document.createElement('span');\n  msgSpan.textContent = message;\n  wrapper.appendChild(msgSpan);\n  toast.appendChild(wrapper);\n\n  document.body.appendChild(toast);\n\n  // Fade in\n  requestAnimationFrame(() => {\n    toast.style.opacity = '1';\n  });\n\n  // Fade out and remove\n  setTimeout(() => {\n    toast.style.opacity = '0';\n    setTimeout(() => toast.remove(), 200);\n  }, durationMs);\n}\n\n// ============================================================================\n// Correction Editing (Learn from user corrections)\n// ============================================================================\n\n/**\n * Make a translated element editable for corrections\n * When the user clicks on a translated element, they can edit it\n * and the correction will be saved for future translations\n */\nfunction makeTranslatedElementEditable(element: HTMLElement): void {\n  // Already set up for editing\n  if (element.hasAttribute('data-correction-enabled')) return;\n\n  element.setAttribute('data-correction-enabled', 'true');\n\n  // Add hover indicator\n  element.style.cursor = 'text';\n\n  // Handle click to enable editing\n  element.addEventListener('click', (e) => {\n    // Only enable editing if not already editing\n    if (element.getAttribute('contenteditable') === 'true') return;\n\n    // Don't interfere with link clicks\n    if ((e.target as Element).closest('a')) return;\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    enableCorrectionEditing(element);\n  });\n}\n\n/**\n * Enable inline editing for a translated element\n */\nfunction enableCorrectionEditing(element: HTMLElement): void {\n  const machineTranslation = element.getAttribute(MACHINE_TRANSLATION_ATTR);\n  const originalText = element.getAttribute(ORIGINAL_TEXT_ATTR);\n  const sourceLang = element.getAttribute(SOURCE_LANG_ATTR);\n  const targetLang = element.getAttribute(TARGET_LANG_ATTR);\n\n  if (!machineTranslation || !originalText || !sourceLang || !targetLang) {\n    log.warn('Missing data for correction editing');\n    return;\n  }\n\n  // Store current state\n  const currentText = element.textContent || '';\n\n  // Make editable\n  element.setAttribute('contenteditable', 'true');\n  element.style.outline = '2px solid #3b82f6';\n  element.style.outlineOffset = '2px';\n  element.style.borderRadius = '2px';\n  element.style.minWidth = '20px';\n  element.focus();\n\n  // Select all text for easy replacement\n  const selection = window.getSelection();\n  const range = document.createRange();\n  range.selectNodeContents(element);\n  selection?.removeAllRanges();\n  selection?.addRange(range);\n\n  // Handle blur (finish editing)\n  const handleBlur = async () => {\n    element.removeAttribute('contenteditable');\n    element.style.outline = '';\n    element.style.outlineOffset = '';\n\n    const newText = element.textContent?.trim() || '';\n\n    // If user cleared the text, restore original\n    if (!newText) {\n      element.textContent = currentText;\n      return;\n    }\n\n    // If text changed and is different from machine translation\n    if (newText !== currentText && newText !== machineTranslation) {\n      try {\n        await browserAPI.runtime.sendMessage({\n          type: 'addCorrection',\n          original: originalText.trim(),\n          machineTranslation: machineTranslation,\n          userCorrection: newText,\n          sourceLang,\n          targetLang,\n        });\n        showInfoToast('Correction saved! Future translations will use your preference.');\n        log.info('Correction saved:', { original: originalText.substring(0, 30), correction: newText.substring(0, 30) });\n      } catch (error) {\n        log.error('Failed to save correction:', error);\n        showErrorToast('Failed to save correction');\n      }\n    } else if (newText === machineTranslation) {\n      // User reverted to machine translation, no correction needed\n      element.textContent = currentText;\n    }\n  };\n\n  element.addEventListener('blur', handleBlur, { once: true });\n\n  // Handle keyboard shortcuts\n  const handleKeyDown = (e: KeyboardEvent) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      element.blur();\n    } else if (e.key === 'Escape') {\n      e.preventDefault();\n      // Restore original text on escape\n      element.textContent = currentText;\n      element.blur();\n    }\n  };\n\n  element.addEventListener('keydown', handleKeyDown);\n\n  // Clean up keydown listener on blur\n  element.addEventListener('blur', () => {\n    element.removeEventListener('keydown', handleKeyDown);\n  }, { once: true });\n}\n\n/**\n * Show a hint tooltip on first translated element hover\n */\nlet correctionHintShown = false;\nfunction showCorrectionHint(_element: HTMLElement): void {\n  if (correctionHintShown) return;\n\n  // Check if we've shown the hint before (use browserAPI for cross-browser compat)\n  const hintKey = 'translate_correction_hint_shown';\n  safeStorageGet<Record<string, boolean>>([hintKey]).then((result) => {\n    if (result[hintKey]) {\n      correctionHintShown = true;\n      return;\n    }\n\n    // Show hint tooltip\n    const hint = document.createElement('div');\n    hint.id = 'translate-correction-hint';\n    Object.assign(hint.style, {\n      position: 'fixed',\n      bottom: '60px',\n      left: '50%',\n      transform: 'translateX(-50%)',\n      background: '#1e40af',\n      color: '#dbeafe',\n      padding: '10px 16px',\n      borderRadius: '8px',\n      fontSize: '13px',\n      fontFamily: 'system-ui, -apple-system, sans-serif',\n      boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',\n      zIndex: '2147483647',\n      maxWidth: '320px',\n      textAlign: 'center',\n      lineHeight: '1.4',\n    });\n    hint.textContent = 'Tip: Click on any translated text to edit it. Your corrections will be remembered for future translations!';\n\n    document.body.appendChild(hint);\n    correctionHintShown = true;\n\n    // Mark as shown in storage (fire-and-forget)\n    browserAPI.storage?.local?.set({ [hintKey]: true }).catch(() => {});\n\n    // Remove after a few seconds\n    setTimeout(() => {\n      hint.style.opacity = '0';\n      hint.style.transition = 'opacity 0.3s ease';\n      setTimeout(() => hint.remove(), 300);\n    }, 6000);\n  }).catch(() => {\n    // Storage not available, just mark as shown\n    correctionHintShown = true;\n  });\n}\n\n// ============================================================================\n// Hover Translation (Alt+Hover)\n// ============================================================================\n\nlet hoverDebounceTimer: number | null = null;\nlet lastHoveredText: string = '';\nlet isAltKeyDown = false;\nconst hoverTranslationCache = new Map<string, string>();\n\n/**\n * Get word or phrase at cursor position\n */\nfunction getTextAtPoint(x: number, y: number): { text: string; range: Range } | null {\n  // Use caretRangeFromPoint if available (Chrome)\n  const range = document.caretRangeFromPoint?.(x, y);\n  if (!range) return null;\n\n  const node = range.startContainer;\n  if (node.nodeType !== Node.TEXT_NODE) return null;\n\n  const parent = node.parentElement;\n  if (!parent || shouldSkip(parent)) return null;\n\n  const text = node.textContent || '';\n  const offset = range.startOffset;\n\n  // Find word boundaries\n  let start = offset;\n  let end = offset;\n\n  // Expand to word boundaries\n  while (start > 0 && /\\S/.test(text[start - 1])) start--;\n  while (end < text.length && /\\S/.test(text[end])) end++;\n\n  const word = text.slice(start, end).trim();\n  if (!word || word.length < 2) return null;\n\n  // Create range for the word\n  const wordRange = document.createRange();\n  wordRange.setStart(node, start);\n  wordRange.setEnd(node, end);\n\n  return { text: word, range: wordRange };\n}\n\n/**\n * Show hover translation tooltip\n */\nfunction showHoverTooltip(text: string, translatedText: string, rect: DOMRect): void {\n  removeHoverTooltip();\n\n  const tooltip = document.createElement('div');\n  tooltip.id = 'translate-hover-tooltip';\n  tooltip.className = 'translate-hover-tooltip';\n\n  tooltip.innerHTML = `\n    <div class=\"hover-original\">${escapeHtml(text)}</div>\n    <div class=\"hover-arrow\">-></div>\n    <div class=\"hover-translation\">${escapeHtml(translatedText)}</div>\n  `;\n\n  Object.assign(tooltip.style, {\n    position: 'fixed',\n    top: `${Math.max(8, rect.top - 50)}px`,\n    left: `${Math.max(8, Math.min(rect.left, window.innerWidth - 320))}px`,\n    maxWidth: '300px',\n    padding: '8px 12px',\n    background: 'linear-gradient(135deg, #1e293b 0%, #334155 100%)',\n    color: '#f1f5f9',\n    borderRadius: '8px',\n    fontSize: '13px',\n    lineHeight: '1.4',\n    boxShadow: '0 8px 24px rgba(0, 0, 0, 0.25)',\n    zIndex: '2147483647',\n    animation: 'hoverFadeIn 0.15s ease',\n    display: 'flex',\n    alignItems: 'center',\n    gap: '8px',\n    pointerEvents: 'none',\n    fontFamily: 'system-ui, -apple-system, sans-serif',\n  });\n\n  document.body.appendChild(tooltip);\n}\n\n/**\n * Show loading tooltip\n */\nfunction showLoadingTooltip(rect: DOMRect): void {\n  removeHoverTooltip();\n\n  const tooltip = document.createElement('div');\n  tooltip.id = 'translate-hover-tooltip';\n  tooltip.innerHTML = `\n    <div style=\"display: flex; align-items: center; gap: 8px;\">\n      <div class=\"hover-spinner\"></div>\n      <span>Translating...</span>\n    </div>\n  `;\n\n  Object.assign(tooltip.style, {\n    position: 'fixed',\n    top: `${Math.max(8, rect.top - 40)}px`,\n    left: `${Math.max(8, Math.min(rect.left, window.innerWidth - 150))}px`,\n    padding: '6px 12px',\n    background: '#1e293b',\n    color: '#94a3b8',\n    borderRadius: '6px',\n    fontSize: '12px',\n    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.2)',\n    zIndex: '2147483647',\n    pointerEvents: 'none',\n    fontFamily: 'system-ui, -apple-system, sans-serif',\n  });\n\n  document.body.appendChild(tooltip);\n}\n\nfunction removeHoverTooltip(): void {\n  const existing = document.getElementById('translate-hover-tooltip');\n  if (existing) existing.remove();\n}\n\nfunction escapeHtml(text: string): string {\n  const div = document.createElement('div');\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n// ============================================================================\n// Floating Translation Widget\n// ============================================================================\n\nlet floatingWidget: HTMLElement | null = null;\nlet widgetVisible = false;\nlet widgetPosition = { x: 20, y: 20 };\nlet isDragging = false;\nlet dragOffset = { x: 0, y: 0 };\nlet widgetDragListenersAdded = false;\n\nconst widgetHistory: Array<{ original: string; translated: string }> = [];\n\n// Named handlers for widget dragging (so we can remove them)\nfunction handleWidgetMouseMove(e: MouseEvent): void {\n  if (!isDragging || !floatingWidget) return;\n\n  const x = Math.max(0, Math.min(window.innerWidth - 280, e.clientX - dragOffset.x));\n  const y = Math.max(0, Math.min(window.innerHeight - 200, e.clientY - dragOffset.y));\n\n  floatingWidget.style.left = `${x}px`;\n  floatingWidget.style.top = `${y}px`;\n  floatingWidget.style.right = 'auto';\n\n  widgetPosition = { x, y };\n}\n\nfunction handleWidgetMouseUp(): void {\n  if (isDragging && floatingWidget) {\n    floatingWidget.style.transition = 'transform 0.2s ease, box-shadow 0.2s ease';\n    isDragging = false;\n  }\n}\n\nfunction addWidgetDragListeners(): void {\n  if (widgetDragListenersAdded) return;\n  document.addEventListener('mousemove', handleWidgetMouseMove);\n  document.addEventListener('mouseup', handleWidgetMouseUp);\n  widgetDragListenersAdded = true;\n}\n\nfunction removeWidgetDragListeners(): void {\n  if (!widgetDragListenersAdded) return;\n  document.removeEventListener('mousemove', handleWidgetMouseMove);\n  document.removeEventListener('mouseup', handleWidgetMouseUp);\n  widgetDragListenersAdded = false;\n}\n\n/**\n * Create the floating widget\n */\nfunction createFloatingWidget(): HTMLElement {\n  const widget = document.createElement('div');\n  widget.id = 'translate-floating-widget';\n  widget.innerHTML = `\n    <div class=\"widget-header\">\n      <span class=\"widget-title\">TRANSLATE!</span>\n      <button class=\"widget-close\" title=\"Close\">&times;</button>\n    </div>\n    <div class=\"widget-body\">\n      <textarea class=\"widget-input\" placeholder=\"Enter text to translate...\" rows=\"2\"></textarea>\n      <div class=\"widget-controls\">\n        <select class=\"widget-lang-select\">\n          <option value=\"en\">English</option>\n          <option value=\"fi\">Finnish</option>\n          <option value=\"sv\">Swedish</option>\n          <option value=\"de\">German</option>\n          <option value=\"fr\">French</option>\n          <option value=\"es\">Spanish</option>\n          <option value=\"nl\">Dutch</option>\n          <option value=\"it\">Italian</option>\n          <option value=\"pt\">Portuguese</option>\n          <option value=\"ja\">Japanese</option>\n          <option value=\"zh\">Chinese</option>\n          <option value=\"ko\">Korean</option>\n          <option value=\"ru\">Russian</option>\n        </select>\n        <button class=\"widget-translate-btn\">Translate</button>\n      </div>\n      <div class=\"widget-output\"></div>\n      <div class=\"widget-history\"></div>\n    </div>\n  `;\n\n  // Apply styles\n  Object.assign(widget.style, {\n    position: 'fixed',\n    top: `${widgetPosition.y}px`,\n    right: `${widgetPosition.x}px`,\n    width: '280px',\n    background: 'linear-gradient(135deg, #1e293b 0%, #0f172a 100%)',\n    borderRadius: '12px',\n    boxShadow: '0 10px 40px rgba(0, 0, 0, 0.3)',\n    zIndex: '2147483646',\n    fontFamily: 'system-ui, -apple-system, sans-serif',\n    color: '#f1f5f9',\n    overflow: 'hidden',\n    transition: 'transform 0.2s ease, box-shadow 0.2s ease',\n  });\n\n  // Header styles\n  const header = widget.querySelector('.widget-header') as HTMLElement;\n  Object.assign(header.style, {\n    display: 'flex',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    padding: '10px 12px',\n    background: 'rgba(255,255,255,0.05)',\n    cursor: 'move',\n    userSelect: 'none',\n  });\n\n  const title = widget.querySelector('.widget-title') as HTMLElement;\n  Object.assign(title.style, {\n    fontSize: '12px',\n    fontWeight: '600',\n    letterSpacing: '0.5px',\n  });\n\n  const closeBtn = widget.querySelector('.widget-close') as HTMLElement;\n  Object.assign(closeBtn.style, {\n    background: 'none',\n    border: 'none',\n    color: '#94a3b8',\n    fontSize: '18px',\n    cursor: 'pointer',\n    padding: '0',\n    lineHeight: '1',\n  });\n\n  // Body styles\n  const body = widget.querySelector('.widget-body') as HTMLElement;\n  Object.assign(body.style, {\n    padding: '12px',\n    display: 'flex',\n    flexDirection: 'column',\n    gap: '10px',\n  });\n\n  // Input styles\n  const input = widget.querySelector('.widget-input') as HTMLTextAreaElement;\n  Object.assign(input.style, {\n    width: '100%',\n    padding: '8px 10px',\n    border: '1px solid #334155',\n    borderRadius: '6px',\n    background: '#0f172a',\n    color: '#f1f5f9',\n    fontSize: '13px',\n    resize: 'none',\n    outline: 'none',\n    fontFamily: 'inherit',\n    boxSizing: 'border-box',\n  });\n\n  // Controls styles\n  const controls = widget.querySelector('.widget-controls') as HTMLElement;\n  Object.assign(controls.style, {\n    display: 'flex',\n    gap: '8px',\n  });\n\n  const langSelect = widget.querySelector('.widget-lang-select') as HTMLSelectElement;\n  Object.assign(langSelect.style, {\n    flex: '1',\n    padding: '6px 8px',\n    border: '1px solid #334155',\n    borderRadius: '6px',\n    background: '#0f172a',\n    color: '#f1f5f9',\n    fontSize: '12px',\n    cursor: 'pointer',\n  });\n\n  const translateBtn = widget.querySelector('.widget-translate-btn') as HTMLButtonElement;\n  Object.assign(translateBtn.style, {\n    padding: '6px 14px',\n    border: 'none',\n    borderRadius: '6px',\n    background: '#3b82f6',\n    color: 'white',\n    fontSize: '12px',\n    fontWeight: '500',\n    cursor: 'pointer',\n  });\n\n  // Output styles\n  const output = widget.querySelector('.widget-output') as HTMLElement;\n  Object.assign(output.style, {\n    minHeight: '40px',\n    padding: '10px',\n    background: 'rgba(255,255,255,0.05)',\n    borderRadius: '6px',\n    fontSize: '13px',\n    lineHeight: '1.5',\n    display: 'none',\n  });\n\n  // History styles\n  const history = widget.querySelector('.widget-history') as HTMLElement;\n  Object.assign(history.style, {\n    maxHeight: '100px',\n    overflowY: 'auto',\n    fontSize: '11px',\n    color: '#94a3b8',\n  });\n\n  // Event handlers\n  closeBtn.addEventListener('click', () => hideFloatingWidget());\n\n  translateBtn.addEventListener('click', async () => {\n    const text = input.value.trim();\n    if (!text) return;\n\n    translateBtn.textContent = '...';\n    translateBtn.disabled = true;\n\n    try {\n      const response = await browserAPI.runtime.sendMessage({\n        type: 'translate',\n        text,\n        sourceLang: 'auto',\n        targetLang: langSelect.value,\n        options: { strategy: 'fast' },\n      }) as TranslateResponse;\n\n      if (response.success && response.result) {\n        output.textContent = response.result as string;\n        output.style.display = 'block';\n\n        // Add to history\n        addToWidgetHistory(text, response.result as string);\n      } else {\n        output.textContent = 'Translation failed';\n        output.style.display = 'block';\n      }\n    } catch (error) {\n      output.textContent = 'Error: ' + String(error);\n      output.style.display = 'block';\n    }\n\n    translateBtn.textContent = 'Translate';\n    translateBtn.disabled = false;\n  });\n\n  // Enter to translate\n  input.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      translateBtn.click();\n    }\n  });\n\n  // Dragging - only attach mousedown to header, document listeners managed separately\n  header.addEventListener('mousedown', (e) => {\n    isDragging = true;\n    const rect = widget.getBoundingClientRect();\n    dragOffset = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top,\n    };\n    widget.style.transition = 'none';\n  });\n\n  // Load saved target language\n  safeStorageGet<{ targetLang?: string }>(['targetLang']).then((settings) => {\n    if (settings.targetLang) {\n      langSelect.value = settings.targetLang;\n    }\n  });\n\n  return widget;\n}\n\nfunction addToWidgetHistory(original: string, translated: string): void {\n  widgetHistory.unshift({ original, translated });\n  if (widgetHistory.length > 5) widgetHistory.pop();\n\n  updateWidgetHistory();\n}\n\nfunction updateWidgetHistory(): void {\n  if (!floatingWidget) return;\n\n  const historyEl = floatingWidget.querySelector('.widget-history') as HTMLElement;\n  if (!historyEl) return;\n\n  if (widgetHistory.length === 0) {\n    historyEl.style.display = 'none';\n    return;\n  }\n\n  historyEl.style.display = 'block';\n  historyEl.innerHTML = widgetHistory\n    .map(\n      (h) => `\n    <div style=\"padding: 4px 0; border-bottom: 1px solid #334155;\">\n      <div style=\"color: #64748b;\">${escapeHtml(h.original.substring(0, 30))}${h.original.length > 30 ? '...' : ''}</div>\n      <div style=\"color: #94a3b8;\">${escapeHtml(h.translated.substring(0, 30))}${h.translated.length > 30 ? '...' : ''}</div>\n    </div>\n  `\n    )\n    .join('');\n}\n\n/**\n * Show floating widget\n */\nfunction showFloatingWidget(): void {\n  if (floatingWidget) {\n    floatingWidget.style.display = 'block';\n    widgetVisible = true;\n    addWidgetDragListeners();\n    return;\n  }\n\n  floatingWidget = createFloatingWidget();\n  document.body.appendChild(floatingWidget);\n  widgetVisible = true;\n  addWidgetDragListeners();\n\n  // Focus input\n  const input = floatingWidget.querySelector('.widget-input') as HTMLTextAreaElement;\n  setTimeout(() => input?.focus(), 100);\n}\n\n/**\n * Hide floating widget\n */\nfunction hideFloatingWidget(): void {\n  if (floatingWidget) {\n    floatingWidget.style.display = 'none';\n    widgetVisible = false;\n    removeWidgetDragListeners();\n  }\n}\n\n/**\n * Toggle floating widget\n */\nfunction toggleFloatingWidget(): boolean {\n  if (widgetVisible) {\n    hideFloatingWidget();\n  } else {\n    showFloatingWidget();\n  }\n  return widgetVisible;\n}\n\n/**\n * Handle hover translation\n */\nasync function handleHoverTranslation(e: MouseEvent): Promise<void> {\n  if (!isAltKeyDown) return;\n\n  const result = getTextAtPoint(e.clientX, e.clientY);\n  if (!result) {\n    removeHoverTooltip();\n    return;\n  }\n\n  const { text, range } = result;\n\n  // Skip if same text\n  if (text === lastHoveredText) return;\n  lastHoveredText = text;\n\n  const rect = range.getBoundingClientRect();\n\n  // Check cache first (LRU: re-insert on hit to keep at end)\n  const cacheKey = text.toLowerCase();\n  const cachedTranslation = hoverTranslationCache.get(cacheKey);\n  if (cachedTranslation !== undefined) {\n    // Touch: move to end of Map for LRU ordering\n    hoverTranslationCache.delete(cacheKey);\n    hoverTranslationCache.set(cacheKey, cachedTranslation);\n    showHoverTooltip(text, cachedTranslation, rect);\n    return;\n  }\n\n  // Show loading\n  showLoadingTooltip(rect);\n\n  try {\n    // Get current settings\n    const settings = await safeStorageGet<{ targetLang?: string; provider?: string }>(['targetLang', 'provider']);\n    const targetLang = settings.targetLang || 'en';\n    const provider = settings.provider || 'opus-mt';\n\n    const response = (await browserAPI.runtime.sendMessage({\n      type: 'translate',\n      text: text,\n      sourceLang: 'auto',\n      targetLang,\n      options: { strategy: 'fast' },\n      provider,\n    })) as TranslateResponse;\n\n    if (response.success && response.result) {\n      const translated = response.result as string;\n      // LRU: delete then re-insert to move to end of Map iteration order\n      hoverTranslationCache.delete(cacheKey);\n      hoverTranslationCache.set(cacheKey, translated);\n\n      // Evict oldest (first) entry when over limit — Map preserves insertion order\n      if (hoverTranslationCache.size > 100) {\n        const firstKey = hoverTranslationCache.keys().next().value;\n        if (firstKey) hoverTranslationCache.delete(firstKey);\n      }\n\n      showHoverTooltip(text, translated, rect);\n    } else {\n      removeHoverTooltip();\n    }\n  } catch (error) {\n    log.error('Hover translation failed:', error);\n    removeHoverTooltip();\n  }\n}\n\n// Debounced hover handler\nfunction onMouseMove(e: MouseEvent): void {\n  if (!isAltKeyDown) return;\n\n  if (hoverDebounceTimer !== null) {\n    clearTimeout(hoverDebounceTimer);\n  }\n\n  hoverDebounceTimer = window.setTimeout(() => {\n    handleHoverTranslation(e);\n  }, 150);\n}\n\n// Key handlers for Alt key\nfunction onKeyDown(e: KeyboardEvent): void {\n  if (e.key === 'Alt' && !isAltKeyDown) {\n    isAltKeyDown = true;\n    document.body.style.cursor = 'help';\n  }\n}\n\nfunction onKeyUp(e: KeyboardEvent): void {\n  if (e.key === 'Alt') {\n    isAltKeyDown = false;\n    document.body.style.cursor = '';\n    removeHoverTooltip();\n    lastHoveredText = '';\n  }\n}\n\n// Initialize hover translation listeners\ndocument.addEventListener('mousemove', onMouseMove, { passive: true });\ndocument.addEventListener('keydown', onKeyDown);\ndocument.addEventListener('keyup', onKeyUp);\nwindow.addEventListener('blur', () => {\n  isAltKeyDown = false;\n  document.body.style.cursor = '';\n  removeHoverTooltip();\n});\n\n// ============================================================================\n// Bilingual Reading Mode\n// ============================================================================\n\nlet bilingualModeEnabled = false;\n\n/**\n * Apply bilingual display to a single translated element.\n * Appends a small original-text annotation after the translated text\n * WITHOUT destroying DOM nodes, event listeners, or text node references.\n */\nfunction applyBilingualToElement(el: Element): void {\n  const originalText = el.getAttribute(ORIGINAL_TEXT_ATTR);\n  if (!originalText) return;\n\n  // Skip if already has bilingual annotation\n  if (el.querySelector('.translate-bilingual-original')) return;\n\n  // Append a subtle original-text annotation (non-destructive)\n  const annotation = document.createElement('span');\n  annotation.className = 'translate-bilingual-original';\n  annotation.textContent = originalText;\n  annotation.setAttribute('aria-hidden', 'true'); // Screen readers skip the duplicate\n\n  el.appendChild(annotation);\n  el.classList.add('translate-bilingual');\n}\n\n/**\n * Remove bilingual annotation from a single element\n */\nfunction removeBilingualFromElement(el: Element): void {\n  const annotation = el.querySelector('.translate-bilingual-original');\n  if (annotation) annotation.remove();\n  el.classList.remove('translate-bilingual');\n}\n\n/**\n * Enable bilingual mode - shows original text below translations.\n * Non-destructive: appends annotation spans without touching existing DOM structure.\n */\nfunction enableBilingualMode(): void {\n  bilingualModeEnabled = true;\n\n  const translated = document.querySelectorAll(`[${TRANSLATED_ATTR}]`);\n  translated.forEach((el) => applyBilingualToElement(el));\n\n  log.info('Bilingual mode enabled');\n  showInfoToast('Bilingual mode: showing originals');\n}\n\n/**\n * Disable bilingual mode - remove original text annotations\n */\nfunction disableBilingualMode(): void {\n  bilingualModeEnabled = false;\n\n  const bilingualElements = document.querySelectorAll('.translate-bilingual');\n  bilingualElements.forEach((el) => removeBilingualFromElement(el));\n\n  log.info('Bilingual mode disabled');\n  showInfoToast('Bilingual mode off');\n}\n\n/**\n * Toggle bilingual mode\n */\nfunction toggleBilingualMode(): boolean {\n  if (bilingualModeEnabled) {\n    disableBilingualMode();\n  } else {\n    enableBilingualMode();\n  }\n  return bilingualModeEnabled;\n}\n\n/**\n * Get current bilingual mode state\n */\nfunction getBilingualModeState(): boolean {\n  return bilingualModeEnabled;\n}\n\n// ============================================================================\n// Element Filtering\n// ============================================================================\n\n/**\n * Check if element should be skipped for translation\n */\nfunction shouldSkip(element: Element): boolean {\n  // Check WeakMap cache first — many text nodes share parents\n  const cached = skipCache.get(element);\n  if (cached !== undefined) return cached;\n\n  const result = shouldSkipUncached(element);\n  skipCache.set(element, result);\n  return result;\n}\n\nfunction shouldSkipUncached(element: Element): boolean {\n  // Skip by tag name (cheapest check first)\n  if (SKIP_TAGS.has(element.tagName)) return true;\n\n  // Skip already translated\n  if (element.getAttribute(TRANSLATED_ATTR)) return true;\n\n  // Skip elements with contenteditable (isContentEditable checks inheritance, avoids DOM traversal)\n  if ((element as HTMLElement).isContentEditable) return true;\n\n  // Skip elements marked as no-translate\n  if (element.hasAttribute('data-no-translate')) return true;\n\n  // Skip elements with translate=\"no\"\n  if (element.getAttribute('translate') === 'no') return true;\n\n  // Check visibility\n  try {\n    const style = window.getComputedStyle(element);\n    if (style.display === 'none' || style.visibility === 'hidden') return true;\n  } catch {\n    // getComputedStyle can throw for detached elements\n    return true;\n  }\n\n  return false;\n}\n\n// Pre-compiled regexes for isValidText (called per text node, thousands/page)\nconst NON_TRANSLATABLE_RE = /^[\\s\\d\\p{P}\\p{S}]+$/u;\nconst CODE_OR_URL_RE = /^(https?:|www\\.|\\/\\/|{|}|\\[|\\]|function|const |let |var )/;\n\n/**\n * Validate text for translation\n */\nfunction isValidText(text: string | null): text is string {\n  if (!text) return false;\n\n  const trimmed = text.trim();\n  if (trimmed.length < CONFIG.batching.minTextLength) return false;\n  if (trimmed.length > CONFIG.batching.maxTextLength) return false;\n\n  // Skip text that's only whitespace, numbers, or symbols\n  if (NON_TRANSLATABLE_RE.test(trimmed)) return false;\n\n  // Skip text that looks like code or URLs\n  if (CODE_OR_URL_RE.test(trimmed)) return false;\n\n  return true;\n}\n\n/**\n * Sanitize text for translation - remove problematic characters\n */\nfunction sanitizeText(text: string): string {\n  return text\n    .normalize('NFC')\n    .replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, '')\n    .replace(/[ \\t]+/g, ' ')\n    .trim();\n}\n\n// ============================================================================\n// DOM Traversal\n// ============================================================================\n\n/**\n * Get all translatable text nodes in element\n */\nfunction getTextNodes(root: Element): Text[] {\n  const nodes: Text[] = [];\n\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {\n    acceptNode: (node) => {\n      const parent = node.parentElement;\n      if (!parent || shouldSkip(parent)) return NodeFilter.FILTER_REJECT;\n      if (!isValidText(node.textContent)) return NodeFilter.FILTER_REJECT;\n      return NodeFilter.FILTER_ACCEPT;\n    },\n  });\n\n  let node: Node | null;\n  while ((node = walker.nextNode())) {\n    nodes.push(node as Text);\n  }\n\n  return nodes;\n}\n\n/**\n * Get text nodes from a specific set of elements (for mutations)\n */\nfunction getTextNodesFromNodes(nodes: Node[]): Text[] {\n  const textNodes: Text[] = [];\n\n  for (const node of nodes) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      const parent = node.parentElement;\n      if (parent && !shouldSkip(parent) && isValidText(node.textContent)) {\n        textNodes.push(node as Text);\n      }\n    } else if (node.nodeType === Node.ELEMENT_NODE) {\n      const element = node as Element;\n      if (!shouldSkip(element)) {\n        textNodes.push(...getTextNodes(element));\n      }\n    }\n  }\n\n  return textNodes;\n}\n\n// ============================================================================\n// Context Extraction for Improved Translation\n// ============================================================================\n\n/**\n * Get surrounding context for better translation of ambiguous words\n * Extracts text before and after the selection from the containing block element\n */\nfunction getSelectionContext(): { before: string; after: string } | null {\n  const selection = window.getSelection();\n  if (!selection || selection.rangeCount === 0) return null;\n\n  const range = selection.getRangeAt(0);\n  const container = range.commonAncestorContainer;\n\n  // Get the paragraph or block element containing the selection\n  const blockElement =\n    container.nodeType === Node.TEXT_NODE\n      ? container.parentElement?.closest('p, div, article, section, li, td, th, blockquote, h1, h2, h3, h4, h5, h6')\n      : (container as Element).closest('p, div, article, section, li, td, th, blockquote, h1, h2, h3, h4, h5, h6');\n\n  if (!blockElement) return null;\n\n  const fullText = blockElement.textContent || '';\n  const selectedText = selection.toString();\n  const selectionIndex = fullText.indexOf(selectedText);\n\n  if (selectionIndex === -1) return null;\n\n  // Extract up to 150 chars before and after for context\n  const maxContextLength = 150;\n  const before = fullText.slice(Math.max(0, selectionIndex - maxContextLength), selectionIndex).trim();\n  const after = fullText\n    .slice(selectionIndex + selectedText.length, selectionIndex + selectedText.length + maxContextLength)\n    .trim();\n\n  // Only return context if there's meaningful text\n  if (!before && !after) return null;\n\n  return { before, after };\n}\n\n// ============================================================================\n// Translation Functions\n// ============================================================================\n\n/**\n * Load glossary if not cached\n */\nasync function loadGlossary(): Promise<GlossaryStore> {\n  if (cachedGlossary === null) {\n    try {\n      cachedGlossary = await glossary.getGlossary();\n    } catch (e) {\n      log.error(' Failed to load glossary:', e);\n      cachedGlossary = {};\n    }\n  }\n  return cachedGlossary;\n}\n\n/**\n * Translate selected text with error handling\n */\nasync function translateSelection(\n  sourceLang: string,\n  targetLang: string,\n  strategy: Strategy,\n  provider?: string\n): Promise<void> {\n  const selection = window.getSelection();\n  if (!selection || selection.isCollapsed) {\n    log.info(' No text selected');\n    showInfoToast('Select text to translate');\n    return;\n  }\n\n  const text = selection.toString().trim();\n  if (!isValidText(text)) {\n    log.info(' Selected text is not valid for translation');\n    showInfoToast('Select text to translate');\n    return;\n  }\n\n  const sanitized = sanitizeText(text);\n\n  // Get surrounding context for better translation of ambiguous words\n  const context = getSelectionContext();\n\n  log.info('Translating selection with context:', {\n    text: sanitized.substring(0, 50),\n    contextBefore: context?.before?.substring(0, 30),\n    contextAfter: context?.after?.substring(0, 30),\n  });\n\n  try {\n    // Apply glossary pre-processing\n    const g = await loadGlossary();\n    const { processedText, restore } = await glossary.applyGlossary(sanitized, g);\n\n    const response = (await browserAPI.runtime.sendMessage({\n      type: 'translate',\n      text: processedText,\n      sourceLang,\n      targetLang,\n      options: {\n        strategy,\n        context: context || undefined,\n      },\n      provider,\n    })) as TranslateResponse;\n\n    if (response.success && response.result) {\n      // Apply glossary post-processing (restore placeholders)\n      const finalResult = restore(response.result as string);\n      showTranslationTooltip(finalResult, selection.getRangeAt(0));\n    } else {\n      log.error(' Translation failed:', response.error);\n      showErrorTooltip(response.error || 'Translation failed', selection.getRangeAt(0));\n    }\n  } catch (error) {\n    log.error(' Translation error:', error);\n    const message = error instanceof Error ? error.message : 'Unknown error';\n    showErrorTooltip(message, selection.getRangeAt(0));\n  }\n}\n\n/**\n * Translate entire page with batching and error handling\n */\n/**\n * Translate a single batch with retry logic for transient failures.\n * Returns { translatedCount, errorCount } for the batch.\n */\nasync function translateBatchWithRetry(\n  batch: { nodes: Text[]; texts: string[]; restoreFns: Array<(text: string) => string> },\n  sourceLang: string,\n  targetLang: string,\n  strategy: Strategy,\n  provider?: string,\n  enableProfiling = false,\n  maxRetries = 2\n): Promise<{ translatedCount: number; errorCount: number; ipcTime: number; domUpdateTime: number }> {\n  let lastError: unknown = null;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      // Exponential backoff on retry\n      if (attempt > 0) {\n        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);\n        await new Promise((r) => setTimeout(r, delay));\n        console.log(`[Content] Retry attempt ${attempt} for batch`);\n      }\n\n      const ipcStart = performance.now();\n      const response = (await browserAPI.runtime.sendMessage({\n        type: 'translate',\n        text: batch.texts,\n        sourceLang,\n        targetLang,\n        options: { strategy },\n        provider,\n        enableProfiling,\n      })) as TranslateResponse;\n      const ipcTime = performance.now() - ipcStart;\n      recordContentTiming('ipcRoundtrip', ipcTime);\n\n      if (response.success && Array.isArray(response.result)) {\n        const domUpdateStart = performance.now();\n        let translatedCount = 0;\n        let errorCount = 0;\n\n        response.result.forEach((translated, idx) => {\n          const node = batch.nodes[idx];\n          // Guard: skip detached nodes (removed from DOM during translation) and already-translated\n          if (node && translated && node.parentElement && document.contains(node) &&\n              !node.parentElement.hasAttribute(TRANSLATED_ATTR)) {\n            try {\n              const finalText = batch.restoreFns[idx](translated);\n              const original = node.textContent || '';\n              const leadingSpace = original.match(/^\\s*/)?.[0] || '';\n              const trailingSpace = original.match(/\\s*$/)?.[0] || '';\n\n              if (!node.parentElement.hasAttribute(ORIGINAL_TEXT_ATTR)) {\n                node.parentElement.setAttribute(ORIGINAL_TEXT_ATTR, original);\n              }\n\n              node.parentElement.setAttribute(MACHINE_TRANSLATION_ATTR, finalText);\n              node.parentElement.setAttribute(SOURCE_LANG_ATTR, sourceLang);\n              node.parentElement.setAttribute(TARGET_LANG_ATTR, targetLang);\n\n              node.textContent = leadingSpace + finalText + trailingSpace;\n              node.parentElement.setAttribute(TRANSLATED_ATTR, 'true');\n              makeTranslatedElementEditable(node.parentElement);\n\n              // Auto-apply bilingual annotation if bilingual mode is active\n              if (bilingualModeEnabled) {\n                applyBilingualToElement(node.parentElement);\n              }\n\n              translatedCount++;\n            } catch {\n              errorCount++;\n            }\n          }\n        });\n\n        const domUpdateTime = performance.now() - domUpdateStart;\n        recordContentTiming('domUpdate', domUpdateTime);\n\n        return { translatedCount, errorCount, ipcTime, domUpdateTime };\n      }\n\n      // Non-retryable error (e.g. unsupported language pair)\n      if (response.error && !isTransientError(response.error)) {\n        return { translatedCount: 0, errorCount: batch.nodes.length, ipcTime, domUpdateTime: 0 };\n      }\n\n      lastError = response.error || 'Translation returned unsuccessful response';\n    } catch (error) {\n      lastError = error;\n      // Extension context invalidated = service worker restarted, not retryable\n      if (error instanceof Error && error.message.includes('Extension context invalidated')) {\n        console.warn('[Content] Extension context invalidated — stopping translation. Reload the page.');\n        stopMutationObserver();\n        currentSettings = null;\n        return { translatedCount: 0, errorCount: batch.nodes.length, ipcTime: 0, domUpdateTime: 0 };\n      }\n      // Other errors are retryable\n      if (attempt === maxRetries) break;\n    }\n  }\n\n  console.error(`[Content] Batch failed after ${maxRetries + 1} attempts:`, lastError);\n  return { translatedCount: 0, errorCount: batch.nodes.length, ipcTime: 0, domUpdateTime: 0 };\n}\n\n/**\n * Check if an error is likely transient and worth retrying.\n * Pre-compiled regex for performance (called on every retry).\n */\nconst TRANSIENT_ERROR_RE = /timeout|network|connection|econnreset|fetch failed|service worker|disconnected|offscreen|loading model/i;\n\nfunction isTransientError(errorMsg: string): boolean {\n  return TRANSIENT_ERROR_RE.test(errorMsg);\n}\n\n/** Active IntersectionObserver for scroll-aware below-fold translation */\nlet belowFoldObserver: IntersectionObserver | null = null;\n\n/**\n * Clean up scroll-aware translation observer\n */\nfunction stopBelowFoldObserver(): void {\n  if (belowFoldObserver) {\n    belowFoldObserver.disconnect();\n    belowFoldObserver = null;\n  }\n}\n\nasync function translatePage(\n  sourceLang: string,\n  targetLang: string,\n  strategy: Strategy,\n  provider?: string,\n  enableProfiling = false\n): Promise<void> {\n  if (isTranslatingPage) {\n    log.info(' Translation already in progress');\n    return;\n  }\n\n  isTranslatingPage = true;\n  stopBelowFoldObserver();\n  log.info(' Translating page...');\n  const pageStart = performance.now();\n\n  try {\n    // Time DOM scanning\n    const scanStart = performance.now();\n    const textNodes = getTextNodes(document.body);\n    const scanDuration = performance.now() - scanStart;\n    recordContentTiming('domScan', scanDuration);\n    console.log(`[Content] Found ${textNodes.length} text nodes in ${scanDuration.toFixed(2)}ms`);\n\n    if (textNodes.length === 0) {\n      log.info(' No translatable text found');\n      return;\n    }\n\n    // Sort nodes: viewport-visible first, then top-to-bottom by position\n    // Users read rendered content top-down, so translate what they see first\n    // Performance: cache getBoundingClientRect() results to avoid redundant layout thrashing\n    const viewportHeight = window.innerHeight;\n    const viewportNodes: Text[] = [];\n    const belowFoldWithPos: Array<{ node: Text; top: number }> = [];\n\n    for (const node of textNodes) {\n      const parent = node.parentElement;\n      if (!parent) continue;\n      try {\n        const rect = parent.getBoundingClientRect();\n        if (rect.top < viewportHeight && rect.bottom > 0) {\n          viewportNodes.push(node);\n        } else {\n          belowFoldWithPos.push({ node, top: rect.top });\n        }\n      } catch {\n        belowFoldWithPos.push({ node, top: Infinity });\n      }\n    }\n\n    // Sort below-fold by cached Y position (no second getBoundingClientRect pass)\n    belowFoldWithPos.sort((a, b) => a.top - b.top);\n    const belowFoldNodes = belowFoldWithPos.map(item => item.node);\n\n    console.log(`[Content] Viewport: ${viewportNodes.length} nodes, below fold: ${belowFoldNodes.length} nodes`);\n\n    // Time glossary loading\n    const glossaryStart = performance.now();\n    const g = await loadGlossary();\n    const glossaryDuration = performance.now() - glossaryStart;\n    recordContentTiming('glossaryApply', glossaryDuration);\n\n    // --- Phase 1: Translate viewport content immediately ---\n    const viewportBatches = await createBatches(viewportNodes, g);\n    const totalBatches = viewportBatches.length;\n    const hasBelowFold = belowFoldNodes.length > 0;\n\n    // Show progress for multi-batch translations\n    if (totalBatches > 1 || hasBelowFold) {\n      showProgressToast(`Translating visible content...`);\n    }\n\n    let translatedCount = 0;\n    let errorCount = 0;\n    let totalIpcTime = 0;\n    let totalDomUpdateTime = 0;\n    let firstTranslation = true;\n\n    // Translate viewport batches with concurrency limit of 2:\n    // Pipelines IPC round-trips while model processes previous batch.\n    // DOM updates happen in-order within each batch's callback.\n    const BATCH_CONCURRENCY = 2;\n    for (let i = 0; i < viewportBatches.length; i += BATCH_CONCURRENCY) {\n      const chunk = viewportBatches.slice(i, i + BATCH_CONCURRENCY);\n\n      if (totalBatches > 1) {\n        updateProgressToast(`Translating... ${i + 1}/${totalBatches}`);\n      }\n\n      const results = await Promise.all(\n        chunk.map((batch) =>\n          translateBatchWithRetry(batch, sourceLang, targetLang, strategy, provider, enableProfiling)\n        )\n      );\n\n      for (let j = 0; j < results.length; j++) {\n        const result = results[j];\n        // Show correction hint on first successful translation\n        if (firstTranslation && result.translatedCount > 0) {\n          const firstNode = chunk[j].nodes[0];\n          if (firstNode?.parentElement) {\n            showCorrectionHint(firstNode.parentElement);\n          }\n          firstTranslation = false;\n        }\n\n        translatedCount += result.translatedCount;\n        errorCount += result.errorCount;\n        totalIpcTime += result.ipcTime;\n        totalDomUpdateTime += result.domUpdateTime;\n      }\n    }\n\n    // --- Phase 2: Translate below-fold content progressively as user scrolls ---\n    if (belowFoldNodes.length > 0) {\n      updateProgressToast(`Translating remaining content...`);\n\n      // Split below-fold nodes into chunks by screen-height sections\n      // Translate the first chunk immediately, defer the rest to scroll\n      const IMMEDIATE_BELOW_FOLD = Math.min(belowFoldNodes.length, CONFIG.batching.maxSize * 2);\n      const immediateNodes = belowFoldNodes.slice(0, IMMEDIATE_BELOW_FOLD);\n      const deferredNodes = belowFoldNodes.slice(IMMEDIATE_BELOW_FOLD);\n\n      // Translate the first section below fold immediately\n      const immediateBatches = await createBatches(immediateNodes, g);\n      for (const batch of immediateBatches) {\n        const result = await translateBatchWithRetry(\n          batch, sourceLang, targetLang, strategy, provider, enableProfiling\n        );\n        translatedCount += result.translatedCount;\n        errorCount += result.errorCount;\n        totalIpcTime += result.ipcTime;\n        totalDomUpdateTime += result.domUpdateTime;\n      }\n\n      // Defer remaining nodes: use IntersectionObserver to translate when approaching viewport\n      if (deferredNodes.length > 0) {\n        setupScrollAwareTranslation(deferredNodes, sourceLang, targetLang, strategy, g, provider, enableProfiling);\n      }\n    }\n\n    removeProgressToast();\n\n    const totalTime = performance.now() - pageStart;\n    console.log(\n      `[Content] Page translation complete: ${translatedCount} translated, ${errorCount} errors\\n` +\n      `  Total: ${totalTime.toFixed(2)}ms\\n` +\n      `  DOM Scan: ${scanDuration.toFixed(2)}ms (${((scanDuration / totalTime) * 100).toFixed(1)}%)\\n` +\n      `  IPC Total: ${totalIpcTime.toFixed(2)}ms (${((totalIpcTime / totalTime) * 100).toFixed(1)}%)\\n` +\n      `  DOM Update: ${totalDomUpdateTime.toFixed(2)}ms (${((totalDomUpdateTime / totalTime) * 100).toFixed(1)}%)`\n    );\n\n    // Show summary\n    if (errorCount > 0 && translatedCount > 0) {\n      showInfoToast(`Translated ${translatedCount} items (${errorCount} failed)`);\n    } else if (translatedCount > 0 && errorCount === 0) {\n      const deferredMsg = belowFoldNodes.length > CONFIG.batching.maxSize * 2\n        ? ' (more translates as you scroll)' : '';\n      showInfoToast(`Translated ${translatedCount} items${deferredMsg}`);\n    } else if (errorCount > 0 && translatedCount === 0) {\n      showErrorToast('Translation failed. Please try again.');\n    }\n\n    // Log content timing stats\n    if (enableProfiling) {\n      console.log('[Content] Timing Stats:', getContentTimingStats());\n    }\n  } finally {\n    isTranslatingPage = false;\n\n    // Drain any dynamic nodes that were queued during page translation\n    if (queuedDynamicNodes.length > 0 && currentSettings) {\n      const queued = queuedDynamicNodes;\n      queuedDynamicNodes = [];\n      log.info(` Draining ${queued.length} queued dynamic nodes`);\n      translateDynamicContent(queued);\n    }\n  }\n}\n\n/**\n * Create translation batches from text nodes with glossary pre-processing\n */\nasync function createBatches(\n  nodes: Text[],\n  g: GlossaryStore\n): Promise<Array<{ nodes: Text[]; texts: string[]; restoreFns: Array<(text: string) => string> }>> {\n  const batches: Array<{ nodes: Text[]; texts: string[]; restoreFns: Array<(text: string) => string> }> = [];\n  for (let i = 0; i < nodes.length; i += CONFIG.batching.maxSize) {\n    const batchNodes = nodes.slice(i, i + CONFIG.batching.maxSize);\n    const rawTexts = batchNodes.map((n) => {\n      const text = sanitizeText(n.textContent || '');\n      return text.length > CONFIG.batching.maxTextLength\n        ? text.substring(0, CONFIG.batching.maxTextLength)\n        : text;\n    });\n\n    const { processedTexts, restoreFns } = await glossary.applyGlossaryBatch(rawTexts, g);\n    batches.push({ nodes: batchNodes, texts: processedTexts, restoreFns });\n  }\n  return batches;\n}\n\n/**\n * Set up IntersectionObserver to translate deferred below-fold content\n * as the user scrolls near it. Translates in chunks using sentinel elements.\n */\nfunction setupScrollAwareTranslation(\n  deferredNodes: Text[],\n  sourceLang: string,\n  targetLang: string,\n  strategy: Strategy,\n  g: GlossaryStore,\n  provider?: string,\n  enableProfiling = false\n): void {\n  // Split deferred nodes into chunks of ~2 batches worth\n  const chunkSize = CONFIG.batching.maxSize * 2;\n  const chunks: Text[][] = [];\n  for (let i = 0; i < deferredNodes.length; i += chunkSize) {\n    chunks.push(deferredNodes.slice(i, i + chunkSize));\n  }\n\n  console.log(`[Content] Deferring ${deferredNodes.length} nodes in ${chunks.length} scroll-triggered chunks`);\n\n  const translatedChunks = new Set<number>();\n\n  belowFoldObserver = new IntersectionObserver(\n    async (entries) => {\n      for (const entry of entries) {\n        if (!entry.isIntersecting) continue;\n\n        const chunkIndex = Number((entry.target as HTMLElement).dataset.translateChunk);\n        if (isNaN(chunkIndex) || translatedChunks.has(chunkIndex)) continue;\n\n        translatedChunks.add(chunkIndex);\n        belowFoldObserver?.unobserve(entry.target);\n\n        const chunk = chunks[chunkIndex];\n        if (!chunk || !currentSettings) return;\n\n        // Filter out nodes that are no longer in the DOM or already translated\n        const validNodes = chunk.filter(\n          (n) => n.parentElement && document.contains(n) && !n.parentElement.hasAttribute(TRANSLATED_ATTR)\n        );\n        if (validNodes.length === 0) return;\n\n        console.log(`[Content] Scroll-triggered: translating chunk ${chunkIndex + 1}/${chunks.length} (${validNodes.length} nodes)`);\n\n        try {\n          const batches = await createBatches(validNodes, g);\n          for (const batch of batches) {\n            await translateBatchWithRetry(\n              batch, sourceLang, targetLang, strategy, provider, enableProfiling\n            );\n          }\n        } catch (error) {\n          console.error(`[Content] Scroll-triggered translation error for chunk ${chunkIndex}:`, error);\n        }\n      }\n    },\n    { rootMargin: '200% 0px' } // Start translating 2 viewports before the user scrolls there\n  );\n\n  // Observe a sentinel element near the first node of each chunk\n  for (let i = 0; i < chunks.length; i++) {\n    const firstNode = chunks[i][0];\n    const parent = firstNode?.parentElement;\n    if (!parent || !document.contains(parent)) continue;\n\n    // Use the parent element as the observation target, tag it with chunk index\n    parent.dataset.translateChunk = String(i);\n    belowFoldObserver.observe(parent);\n  }\n}\n\n/**\n * Translate dynamically added content (with batching to respect MAX_BATCH_SIZE)\n */\nasync function translateDynamicContent(nodes: Node[]): Promise<void> {\n  if (!currentSettings) return;\n\n  // If page translation is running, queue these nodes instead of dropping them\n  if (isTranslatingPage) {\n    queuedDynamicNodes.push(...nodes);\n    return;\n  }\n\n  if (isTranslatingDynamic) return;\n  isTranslatingDynamic = true;\n\n  const textNodes = getTextNodesFromNodes(nodes);\n  if (textNodes.length === 0) return;\n\n  console.log(`[Content] Translating ${textNodes.length} dynamic text nodes`);\n\n  try {\n    const g = await loadGlossary();\n    const batches = await createBatches(textNodes, g);\n\n    for (const batch of batches) {\n      if (!currentSettings) return; // Settings cleared (e.g. undo called)\n\n      const result = await translateBatchWithRetry(\n        batch,\n        currentSettings.sourceLang,\n        currentSettings.targetLang,\n        currentSettings.strategy,\n        currentSettings.provider,\n        false, // enableProfiling\n        1      // maxRetries: fewer retries for dynamic content to avoid blocking\n      );\n\n      if (result.errorCount > 0 && result.translatedCount === 0) {\n        log.error(` Dynamic batch fully failed (${result.errorCount} nodes)`);\n      }\n    }\n  } catch (error) {\n    log.error(' Dynamic translation error:', error);\n    // Only show error toast for non-transient failures to avoid spamming the user\n    if (error instanceof Error && !isTransientError(error.message)) {\n      showErrorToast(error.message);\n    }\n  } finally {\n    isTranslatingDynamic = false;\n  }\n}\n\n// ============================================================================\n// Undo Translation\n// ============================================================================\n\n/**\n * Undo all translations on the page, restoring original text\n */\nfunction undoTranslation(): number {\n  // Stop any ongoing mutation observation\n  stopMutationObserver();\n  currentSettings = null;\n\n  // Count and clear image translation overlays\n  const imageOverlayCount = imageTranslationOverlays.length;\n  clearImageOverlays();\n\n  // Find all translated elements\n  const translatedElements = document.querySelectorAll(`[${TRANSLATED_ATTR}]`);\n  let restoredCount = imageOverlayCount;\n\n  translatedElements.forEach((element) => {\n    const originalText = element.getAttribute(ORIGINAL_TEXT_ATTR);\n    if (originalText !== null) {\n      // Find the text node and restore original\n      const textNode = Array.from(element.childNodes).find(\n        (node) => node.nodeType === Node.TEXT_NODE\n      );\n      if (textNode) {\n        textNode.textContent = originalText;\n        restoredCount++;\n      }\n    }\n\n    // Clean up attributes and invalidate skip cache\n    element.removeAttribute(TRANSLATED_ATTR);\n    element.removeAttribute(ORIGINAL_TEXT_ATTR);\n    skipCache.delete(element);\n  });\n\n  log.info(` Restored ${restoredCount} elements to original text`);\n  showInfoToast(`Restored ${restoredCount} translations`);\n  return restoredCount;\n}\n\n// ============================================================================\n// MutationObserver for Dynamic Content\n// ============================================================================\n\n/**\n * Process pending mutations with debouncing and chunked processing.\n * Caps per-cycle processing to avoid blocking the main thread on\n * content-heavy pages that generate hundreds of mutations.\n */\nconst MUTATION_BATCH_CAP = 100;\n\nfunction processPendingMutations(): void {\n  if (pendingMutations.length === 0) return;\n\n  // Collect all added nodes\n  const addedNodes: Node[] = [];\n  for (const mutation of pendingMutations) {\n    for (const node of mutation.addedNodes) {\n      if (\n        node.nodeType === Node.ELEMENT_NODE ||\n        node.nodeType === Node.TEXT_NODE\n      ) {\n        addedNodes.push(node);\n      }\n    }\n  }\n\n  pendingMutations = [];\n\n  if (addedNodes.length === 0) return;\n\n  // Process in capped chunks to avoid main-thread jank\n  if (addedNodes.length <= MUTATION_BATCH_CAP) {\n    translateDynamicContent(addedNodes);\n  } else {\n    // Process first chunk immediately\n    translateDynamicContent(addedNodes.slice(0, MUTATION_BATCH_CAP));\n    // Defer remaining chunks via requestIdleCallback / setTimeout\n    let offset = MUTATION_BATCH_CAP;\n    const processNextChunk = () => {\n      if (offset >= addedNodes.length) return;\n      const chunk = addedNodes.slice(offset, offset + MUTATION_BATCH_CAP);\n      offset += MUTATION_BATCH_CAP;\n      translateDynamicContent(chunk);\n      if (offset < addedNodes.length) {\n        if ('requestIdleCallback' in window) {\n          (window as unknown as { requestIdleCallback: (cb: () => void) => void }).requestIdleCallback(processNextChunk);\n        } else {\n          setTimeout(processNextChunk, 50);\n        }\n      }\n    };\n    if ('requestIdleCallback' in window) {\n      (window as unknown as { requestIdleCallback: (cb: () => void) => void }).requestIdleCallback(processNextChunk);\n    } else {\n      setTimeout(processNextChunk, 50);\n    }\n  }\n}\n\n/**\n * Start observing DOM mutations for auto-translation\n */\nfunction startMutationObserver(): void {\n  if (mutationObserver) return;\n\n  mutationObserver = new MutationObserver((mutations) => {\n    // Add to pending mutations\n    for (const mutation of mutations) {\n      if (pendingMutations.length < CONFIG.mutations.maxPending) {\n        pendingMutations.push(mutation);\n      }\n    }\n\n    // Debounce processing\n    if (mutationDebounceTimer !== null) {\n      clearTimeout(mutationDebounceTimer);\n    }\n\n    mutationDebounceTimer = window.setTimeout(() => {\n      mutationDebounceTimer = null;\n      processPendingMutations();\n    }, CONFIG.mutations.debounceMs);\n  });\n\n  mutationObserver.observe(document.body, {\n    childList: true,\n    subtree: true,\n  });\n\n  log.info(' MutationObserver started');\n}\n\n/**\n * Stop observing DOM mutations\n */\nfunction stopMutationObserver(): void {\n  if (mutationObserver) {\n    mutationObserver.disconnect();\n    mutationObserver = null;\n  }\n\n  if (mutationDebounceTimer !== null) {\n    clearTimeout(mutationDebounceTimer);\n    mutationDebounceTimer = null;\n  }\n\n  pendingMutations = [];\n  stopBelowFoldObserver();\n  removeProgressToast();\n  log.info(' MutationObserver stopped');\n}\n\n// ============================================================================\n// Image Translation (OCR)\n// ============================================================================\n\n/** Stores active image translation overlays for cleanup */\nlet imageTranslationOverlays: HTMLElement[] = [];\n\n/**\n * OCR block with translation\n */\ninterface TranslatedBlock {\n  original: string;\n  translated: string;\n  bbox: { x0: number; y0: number; x1: number; y1: number };\n}\n\n/**\n * Create translation overlay for an image\n * Positions translated text blocks over the original image\n */\nfunction createImageOverlay(img: HTMLImageElement, translatedBlocks: TranslatedBlock[]): HTMLElement {\n  const overlay = document.createElement('div');\n  overlay.className = 'translate-image-overlay';\n\n  const rect = img.getBoundingClientRect();\n  const scaleX = rect.width / img.naturalWidth;\n  const scaleY = rect.height / img.naturalHeight;\n\n  Object.assign(overlay.style, {\n    position: 'absolute',\n    top: `${rect.top + window.scrollY}px`,\n    left: `${rect.left + window.scrollX}px`,\n    width: `${rect.width}px`,\n    height: `${rect.height}px`,\n    pointerEvents: 'none',\n    zIndex: '999998',\n  });\n\n  translatedBlocks.forEach((block) => {\n    const blockEl = document.createElement('div');\n    blockEl.className = 'translate-image-block';\n    blockEl.textContent = block.translated;\n\n    const blockWidth = (block.bbox.x1 - block.bbox.x0) * scaleX;\n    const blockHeight = (block.bbox.y1 - block.bbox.y0) * scaleY;\n    const fontSize = Math.max(10, Math.min(blockHeight * 0.7, 24));\n\n    Object.assign(blockEl.style, {\n      position: 'absolute',\n      left: `${block.bbox.x0 * scaleX}px`,\n      top: `${block.bbox.y0 * scaleY}px`,\n      width: `${blockWidth}px`,\n      minHeight: `${blockHeight}px`,\n      background: 'rgba(255, 255, 255, 0.95)',\n      color: '#1e293b',\n      padding: '2px 4px',\n      fontSize: `${fontSize}px`,\n      lineHeight: '1.2',\n      overflow: 'hidden',\n      borderRadius: '2px',\n      boxShadow: '0 1px 3px rgba(0,0,0,0.2)',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      textAlign: 'center',\n      wordBreak: 'break-word',\n    });\n\n    // Add title with original text for hover\n    blockEl.title = `Original: ${block.original}`;\n\n    overlay.appendChild(blockEl);\n  });\n\n  document.body.appendChild(overlay);\n  imageTranslationOverlays.push(overlay);\n\n  return overlay;\n}\n\n/**\n * Find the image element on the page that matches the URL\n */\nfunction findImageByUrl(url: string): HTMLImageElement | null {\n  const images = document.querySelectorAll('img');\n  for (const img of images) {\n    if (img.src === url || img.currentSrc === url) {\n      return img;\n    }\n  }\n  return null;\n}\n\n/**\n * Convert image URL to data URL for OCR processing\n */\nasync function imageUrlToDataUrl(imageUrl: string): Promise<string> {\n  // First try to find the image in the DOM to get its dimensions\n  const img = findImageByUrl(imageUrl);\n\n  if (img && img.complete && img.naturalWidth > 0) {\n    // Image is in DOM and loaded - use canvas to get data URL\n    const canvas = document.createElement('canvas');\n    canvas.width = img.naturalWidth;\n    canvas.height = img.naturalHeight;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) throw new Error('Canvas not supported');\n\n    ctx.drawImage(img, 0, 0);\n    return canvas.toDataURL('image/png');\n  }\n\n  // Image not in DOM or not loaded - fetch it\n  try {\n    const response = await fetch(imageUrl, { mode: 'cors' });\n    const blob = await response.blob();\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => resolve(reader.result as string);\n      reader.onerror = reject;\n      reader.readAsDataURL(blob);\n    });\n  } catch (error) {\n    // CORS error - try loading via Image element\n    return new Promise((resolve, reject) => {\n      const tempImg = new Image();\n      tempImg.crossOrigin = 'anonymous';\n      tempImg.onload = () => {\n        const canvas = document.createElement('canvas');\n        canvas.width = tempImg.naturalWidth;\n        canvas.height = tempImg.naturalHeight;\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n          reject(new Error('Canvas not supported'));\n          return;\n        }\n        ctx.drawImage(tempImg, 0, 0);\n        try {\n          resolve(canvas.toDataURL('image/png'));\n        } catch (e) {\n          reject(new Error('Cannot access image due to CORS policy'));\n        }\n      };\n      tempImg.onerror = () => reject(new Error('Failed to load image'));\n      tempImg.src = imageUrl;\n    });\n  }\n}\n\n/**\n * OCR response from background\n */\ninterface OCRResponse {\n  success: boolean;\n  text?: string;\n  confidence?: number;\n  blocks?: Array<{\n    text: string;\n    confidence: number;\n    bbox: { x0: number; y0: number; x1: number; y1: number };\n  }>;\n  error?: string;\n}\n\n/**\n * Translate text in an image using OCR\n */\nasync function translateImage(\n  imageUrl: string,\n  sourceLang: string,\n  targetLang: string,\n  provider?: string\n): Promise<void> {\n  showInfoToast('Extracting text from image...');\n\n  try {\n    // Convert image to data URL for OCR\n    let imageData: string;\n    try {\n      imageData = await imageUrlToDataUrl(imageUrl);\n    } catch (error) {\n      log.error('Failed to load image:', error);\n      showErrorToast('Cannot access image (CORS restriction)');\n      return;\n    }\n\n    // Send to background for OCR\n    const ocrResult = (await browserAPI.runtime.sendMessage({\n      type: 'ocrImage',\n      imageData,\n      lang: sourceLang !== 'auto' ? sourceLang : undefined,\n    })) as OCRResponse;\n\n    if (!ocrResult.success) {\n      showErrorToast(ocrResult.error || 'OCR failed');\n      return;\n    }\n\n    if (!ocrResult.blocks || ocrResult.blocks.length === 0) {\n      showInfoToast('No text found in image');\n      return;\n    }\n\n    log.info(`OCR found ${ocrResult.blocks.length} text blocks (${ocrResult.confidence?.toFixed(1)}% confidence)`);\n    showInfoToast(`Translating ${ocrResult.blocks.length} text blocks...`);\n\n    // Translate each block\n    const translatedBlocks: TranslatedBlock[] = [];\n\n    for (const block of ocrResult.blocks) {\n      // Skip very short text (likely noise)\n      if (block.text.trim().length < 2) continue;\n\n      // Skip low confidence blocks\n      if (block.confidence < 50) {\n        log.debug(`Skipping low confidence block: \"${block.text}\" (${block.confidence.toFixed(1)}%)`);\n        continue;\n      }\n\n      try {\n        const response = (await browserAPI.runtime.sendMessage({\n          type: 'translate',\n          text: block.text,\n          sourceLang,\n          targetLang,\n          provider,\n        })) as TranslateResponse;\n\n        if (response.success && response.result) {\n          translatedBlocks.push({\n            original: block.text,\n            translated: response.result as string,\n            bbox: block.bbox,\n          });\n        }\n      } catch (error) {\n        log.warn(`Failed to translate block: \"${block.text}\"`, error);\n      }\n    }\n\n    if (translatedBlocks.length === 0) {\n      showInfoToast('Could not translate image text');\n      return;\n    }\n\n    // Find the image element and create overlay\n    const img = findImageByUrl(imageUrl);\n    if (img) {\n      createImageOverlay(img, translatedBlocks);\n      showInfoToast(`Translated ${translatedBlocks.length} text blocks`);\n    } else {\n      log.warn('Could not find image element for overlay');\n      showInfoToast(`Translated ${translatedBlocks.length} blocks (overlay unavailable)`);\n    }\n  } catch (error) {\n    log.error('Image translation failed:', error);\n    // Provide more specific error message based on error type\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    if (errorMessage.includes('CORS') || errorMessage.includes('cross-origin')) {\n      showErrorToast('Cannot translate: Image is from another website (CORS blocked)');\n    } else if (errorMessage.includes('Canvas') || errorMessage.includes('tainted')) {\n      showErrorToast('Cannot translate: Browser security prevents accessing this image');\n    } else if (errorMessage.includes('timeout') || errorMessage.includes('Timeout')) {\n      showErrorToast('Image translation timed out. Try a smaller image.');\n    } else {\n      showErrorToast('Image translation failed: ' + errorMessage.substring(0, 50));\n    }\n  }\n}\n\n/**\n * Clear all image translation overlays\n */\nfunction clearImageOverlays(): void {\n  imageTranslationOverlays.forEach((overlay) => overlay.remove());\n  imageTranslationOverlays = [];\n}\n\n// ============================================================================\n// UI Components\n// ============================================================================\n\n/**\n * Show translation tooltip\n */\nfunction showTranslationTooltip(text: string, range: Range): void {\n  removeTooltip();\n\n  const rect = range.getBoundingClientRect();\n\n  const tooltip = document.createElement('div');\n  tooltip.id = 'translate-tooltip';\n  tooltip.textContent = text;\n  tooltip.style.cssText = `\n    position: fixed;\n    top: ${Math.min(rect.bottom + 8, window.innerHeight - 100)}px;\n    left: ${Math.max(8, Math.min(rect.left, window.innerWidth - 416))}px;\n    max-width: 400px;\n    padding: 12px 16px;\n    background: #1e293b;\n    color: white;\n    border-radius: 8px;\n    font-size: 14px;\n    line-height: 1.5;\n    box-shadow: 0 10px 25px rgba(0,0,0,0.2);\n    z-index: 999999;\n    animation: translateFadeIn 0.2s ease;\n    word-wrap: break-word;\n  `;\n\n  // Add close button\n  const closeBtn = document.createElement('button');\n  closeBtn.innerHTML = '&times;';\n  closeBtn.style.cssText = `\n    position: absolute;\n    top: 4px;\n    right: 8px;\n    background: none;\n    border: none;\n    color: #94a3b8;\n    font-size: 18px;\n    cursor: pointer;\n    padding: 0;\n    line-height: 1;\n  `;\n  closeBtn.onclick = () => removeTooltip();\n  tooltip.appendChild(closeBtn);\n\n  document.body.appendChild(tooltip);\n\n  // Auto-remove after 10 seconds\n  setTimeout(() => removeTooltip(), 10000);\n}\n\n/**\n * Show error tooltip\n */\nfunction showErrorTooltip(message: string, range: Range): void {\n  removeTooltip();\n\n  const rect = range.getBoundingClientRect();\n\n  const tooltip = document.createElement('div');\n  tooltip.id = 'translate-tooltip';\n  tooltip.style.cssText = `\n    position: fixed;\n    top: ${Math.min(rect.bottom + 8, window.innerHeight - 100)}px;\n    left: ${Math.max(8, Math.min(rect.left, window.innerWidth - 416))}px;\n    max-width: 400px;\n    padding: 12px 16px;\n    background: #991b1b;\n    color: white;\n    border-radius: 8px;\n    font-size: 14px;\n    line-height: 1.5;\n    box-shadow: 0 10px 25px rgba(0,0,0,0.2);\n    z-index: 999999;\n    animation: translateFadeIn 0.2s ease;\n  `;\n\n  tooltip.textContent = message;\n\n  // Add close button\n  const closeBtn = document.createElement('button');\n  closeBtn.innerHTML = '&times;';\n  closeBtn.style.cssText = `\n    position: absolute;\n    top: 4px;\n    right: 8px;\n    background: none;\n    border: none;\n    color: #fca5a5;\n    font-size: 18px;\n    cursor: pointer;\n    padding: 0;\n    line-height: 1;\n  `;\n  closeBtn.onclick = () => removeTooltip();\n  tooltip.appendChild(closeBtn);\n\n  document.body.appendChild(tooltip);\n\n  // Auto-remove after 5 seconds\n  setTimeout(() => removeTooltip(), 5000);\n}\n\n/**\n * Remove tooltip\n */\nfunction removeTooltip(): void {\n  const existing = document.getElementById('translate-tooltip');\n  if (existing) existing.remove();\n}\n\n// Add animation styles\nconst style = document.createElement('style');\nstyle.textContent = `\n  @keyframes translateFadeIn {\n    from { opacity: 0; transform: translateY(-4px); }\n    to { opacity: 1; transform: translateY(0); }\n  }\n  @keyframes hoverFadeIn {\n    from { opacity: 0; transform: translateY(4px); }\n    to { opacity: 1; transform: translateY(0); }\n  }\n  .hover-spinner {\n    width: 12px;\n    height: 12px;\n    border: 2px solid #475569;\n    border-top-color: #60a5fa;\n    border-radius: 50%;\n    animation: spin 0.8s linear infinite;\n  }\n  @keyframes spin {\n    to { transform: rotate(360deg); }\n  }\n  .hover-original { color: #94a3b8; }\n  .hover-arrow { color: #60a5fa; font-weight: bold; }\n  .hover-translation { color: #f1f5f9; font-weight: 500; }\n\n  /* Bilingual Reading Mode - non-destructive annotation */\n  .translate-bilingual {\n    position: relative;\n  }\n  .translate-bilingual-original {\n    display: block;\n    font-size: 0.8em;\n    line-height: 1.3;\n    color: #6b7280;\n    font-style: italic;\n    opacity: 0.7;\n    margin-top: 1px;\n    pointer-events: none;\n    user-select: none;\n  }\n  /* Inline elements (span, a, em, strong) — keep annotation inline-block to avoid breaking flow */\n  span.translate-bilingual > .translate-bilingual-original,\n  a.translate-bilingual > .translate-bilingual-original,\n  em.translate-bilingual > .translate-bilingual-original,\n  strong.translate-bilingual > .translate-bilingual-original {\n    display: inline-block;\n    margin-top: 0;\n    margin-left: 4px;\n    vertical-align: baseline;\n  }\n  /* Inline elements: parenthesized format for compact display */\n  span.translate-bilingual > .translate-bilingual-original::before { content: '('; }\n  span.translate-bilingual > .translate-bilingual-original::after { content: ')'; }\n  a.translate-bilingual > .translate-bilingual-original::before { content: '('; }\n  a.translate-bilingual > .translate-bilingual-original::after { content: ')'; }\n  em.translate-bilingual > .translate-bilingual-original::before { content: '('; }\n  em.translate-bilingual > .translate-bilingual-original::after { content: ')'; }\n  strong.translate-bilingual > .translate-bilingual-original::before { content: '('; }\n  strong.translate-bilingual > .translate-bilingual-original::after { content: ')'; }\n  @media (prefers-color-scheme: dark) {\n    .translate-bilingual-original {\n      color: #9ca3af;\n    }\n  }\n\n  /* Image Translation Overlay */\n  .translate-image-overlay {\n    pointer-events: none;\n  }\n  .translate-image-block {\n    pointer-events: auto;\n    cursor: help;\n    transition: transform 0.1s ease;\n  }\n  .translate-image-block:hover {\n    transform: scale(1.02);\n    z-index: 1;\n  }\n`;\ndocument.head.appendChild(style);\n\n// ============================================================================\n// Message Handling\n// ============================================================================\n\nbrowserAPI.runtime.onMessage.addListener(\n  (\n    message: ContentMessage,\n    _sender,\n    sendResponse: (response: boolean | { loaded: boolean } | { success: boolean; restoredCount: number } | { enabled: boolean } | { visible: boolean }) => void\n  ) => {\n    if (message.type === 'ping') {\n      sendResponse({ loaded: true });\n      return true;\n    }\n\n    if (message.type === 'stopAutoTranslate') {\n      stopMutationObserver();\n      currentSettings = null;\n      sendResponse(true);\n      return true;\n    }\n\n    if (message.type === 'undoTranslation') {\n      const restoredCount = undoTranslation();\n      sendResponse({ success: true, restoredCount });\n      return true;\n    }\n\n    if (message.type === 'toggleBilingualMode') {\n      const enabled = toggleBilingualMode();\n      sendResponse({ enabled });\n      return true;\n    }\n\n    if (message.type === 'setBilingualMode') {\n      if (message.enabled) {\n        enableBilingualMode();\n      } else {\n        disableBilingualMode();\n      }\n      sendResponse({ enabled: getBilingualModeState() });\n      return true;\n    }\n\n    if (message.type === 'getBilingualMode') {\n      sendResponse({ enabled: getBilingualModeState() });\n      return true;\n    }\n\n    if (message.type === 'toggleWidget') {\n      const visible = toggleFloatingWidget();\n      sendResponse({ visible });\n      return true;\n    }\n\n    if (message.type === 'showWidget') {\n      showFloatingWidget();\n      sendResponse({ visible: true });\n      return true;\n    }\n\n    if (message.type === 'translateSelection') {\n      translateSelection(message.sourceLang, message.targetLang, message.strategy, message.provider)\n        .then(() => sendResponse(true))\n        .catch(() => sendResponse(false));\n      return true;\n    }\n\n    if (message.type === 'translatePage') {\n      // Store settings for dynamic content translation\n      currentSettings = {\n        sourceLang: message.sourceLang,\n        targetLang: message.targetLang,\n        strategy: message.strategy,\n        provider: message.provider,\n      };\n\n      translatePage(message.sourceLang, message.targetLang, message.strategy, message.provider)\n        .then(() => {\n          // Start observing for dynamic content\n          startMutationObserver();\n          sendResponse(true);\n        })\n        .catch(() => sendResponse(false));\n      return true;\n    }\n\n    if (message.type === 'translateImage') {\n      translateImage(\n        message.imageUrl,\n        message.sourceLang,\n        message.targetLang,\n        message.provider\n      )\n        .then(() => sendResponse(true))\n        .catch(() => sendResponse(false));\n      return true;\n    }\n\n    return false;\n  }\n);\n\n// ============================================================================\n// Auto-Translate Check\n// ============================================================================\n\nasync function checkAutoTranslate(): Promise<void> {\n  // First check per-site rules\n  const hostname = window.location.hostname;\n  const siteSpecificRules = await siteRules.getRules(hostname);\n\n  // Get global settings as fallback\n  interface StoredSettings {\n    autoTranslate?: boolean;\n    sourceLang?: string;\n    targetLang?: string;\n    strategy?: Strategy;\n    provider?: TranslationProviderId;\n  }\n  const settings = await safeStorageGet<StoredSettings>([\n    'autoTranslate',\n    'sourceLang',\n    'targetLang',\n    'strategy',\n    'provider',\n  ]);\n\n  // Merge settings: site rules take precedence over global settings\n  const shouldAutoTranslate = siteSpecificRules?.autoTranslate ?? settings.autoTranslate;\n  const sourceLang = siteSpecificRules?.sourceLang || settings.sourceLang || 'auto';\n  const targetLang = siteSpecificRules?.targetLang || settings.targetLang || 'fi';\n  const strategy = siteSpecificRules?.strategy || settings.strategy || 'smart';\n  const provider = siteSpecificRules?.preferredProvider || settings.provider || 'opus-mt';\n\n  if (siteSpecificRules) {\n    log.info(' Site-specific rules found for', hostname, siteSpecificRules);\n  }\n\n  if (shouldAutoTranslate) {\n    log.info(' Auto-translate enabled, waiting for page idle...');\n\n    currentSettings = {\n      sourceLang,\n      targetLang,\n      strategy: strategy as Strategy,\n      provider: provider as TranslationProviderId,\n    };\n\n    // Wait for browser idle to avoid competing with page rendering.\n    // requestIdleCallback fires when browser has spare cycles; fallback to 500ms for Firefox.\n    const startTranslation = () => {\n      if (!currentSettings) return; // User may have cancelled\n      translatePage(\n        currentSettings.sourceLang,\n        currentSettings.targetLang,\n        currentSettings.strategy,\n        currentSettings.provider\n      ).then(() => {\n        startMutationObserver();\n      });\n    };\n\n    if ('requestIdleCallback' in window) {\n      (window as Window).requestIdleCallback(startTranslation, { timeout: 2000 });\n    } else {\n      setTimeout(startTranslation, 500);\n    }\n  }\n}\n\n// Run auto-translate check on load\nif (document.readyState === 'complete') {\n  checkAutoTranslate();\n} else {\n  window.addEventListener('load', checkAutoTranslate);\n}\n\n// Cleanup on unload - release all resources\nwindow.addEventListener('unload', () => {\n  stopMutationObserver();\n  stopBelowFoldObserver();\n  removeProgressToast();\n  clearImageOverlays();\n  hoverTranslationCache.clear();\n  queuedDynamicNodes = [];\n  currentSettings = null;\n  cachedGlossary = null;\n\n  // Remove hover translation listeners\n  document.removeEventListener('mousemove', onMouseMove);\n  document.removeEventListener('keydown', onKeyDown);\n  document.removeEventListener('keyup', onKeyUp);\n  removeWidgetDragListeners();\n});\n\nlog.info(' Translation content script loaded v2.3 with MutationObserver + site rules + glossary support');\n"],"names":["createLogger","module","msg","args","log","STORAGE_KEY","matchesPattern","hostname","pattern","baseDomain","findMatchingRule","rules","wildcardPatterns","a","b","getRules","allRules","match","setRules","hostnameOrPattern","e","clearRules","getAllRules","clearAllRules","exportRules","importRules","json","imported","merged","siteRules","PLACEHOLDER_PREFIX","PLACEHOLDER_SUFFIX","getGlossary","addTerm","term","replacement","caseSensitive","description","glossary","removeTerm","clearGlossary","createTermRegex","escaped","applyGlossaryPreProcess","text","result","sortedTerms","entry","regex","applyGlossaryWithPlaceholders","placeholderMap","placeholderIndex","placeholder","restorePlaceholders","applyGlossary","g","t","processedText","translated","applyGlossaryBatch","texts","results","exportGlossary","importGlossary","CONFIG","browserAPI","safeStorageGet","keys","error","TIMING_BUFFER_SIZE","CircularTimingBuffer","size","value","sum","min","max","i","val","contentTimings","recordContentTiming","category","durationMs","getContentTimingStats","key","buffer","stats","SKIP_TAGS","TRANSLATED_ATTR","ORIGINAL_TEXT_ATTR","MACHINE_TRANSLATION_ATTR","SOURCE_LANG_ATTR","TARGET_LANG_ATTR","isTranslatingPage","isTranslatingDynamic","pendingMutations","mutationDebounceTimer","mutationObserver","queuedDynamicNodes","skipCache","currentSettings","cachedGlossary","activeProgressToast","showInfoToast","message","existing","toast","showProgressToast","removeProgressToast","updateProgressToast","textEl","showErrorToast","wrapper","msgSpan","makeTranslatedElementEditable","element","enableCorrectionEditing","machineTranslation","originalText","sourceLang","targetLang","currentText","selection","range","handleBlur","newText","handleKeyDown","correctionHintShown","showCorrectionHint","_element","hintKey","hint","hoverDebounceTimer","lastHoveredText","isAltKeyDown","hoverTranslationCache","getTextAtPoint","x","y","node","parent","shouldSkip","offset","start","end","word","wordRange","showHoverTooltip","translatedText","rect","removeHoverTooltip","tooltip","escapeHtml","showLoadingTooltip","div","floatingWidget","widgetVisible","widgetPosition","isDragging","dragOffset","widgetDragListenersAdded","widgetHistory","handleWidgetMouseMove","handleWidgetMouseUp","addWidgetDragListeners","removeWidgetDragListeners","createFloatingWidget","widget","header","title","closeBtn","body","input","controls","langSelect","translateBtn","output","history","hideFloatingWidget","response","addToWidgetHistory","settings","original","updateWidgetHistory","historyEl","h","showFloatingWidget","toggleFloatingWidget","handleHoverTranslation","cacheKey","cachedTranslation","provider","firstKey","onMouseMove","onKeyDown","onKeyUp","bilingualModeEnabled","applyBilingualToElement","el","annotation","removeBilingualFromElement","enableBilingualMode","disableBilingualMode","toggleBilingualMode","getBilingualModeState","cached","shouldSkipUncached","style","NON_TRANSLATABLE_RE","CODE_OR_URL_RE","isValidText","trimmed","sanitizeText","getTextNodes","root","nodes","walker","getTextNodesFromNodes","textNodes","getSelectionContext","container","blockElement","fullText","selectedText","selectionIndex","maxContextLength","before","after","loadGlossary","translateSelection","strategy","sanitized","context","restore","finalResult","showTranslationTooltip","showErrorTooltip","translateBatchWithRetry","batch","enableProfiling","maxRetries","lastError","attempt","delay","r","ipcStart","ipcTime","domUpdateStart","translatedCount","errorCount","idx","finalText","leadingSpace","trailingSpace","domUpdateTime","isTransientError","stopMutationObserver","TRANSIENT_ERROR_RE","errorMsg","belowFoldObserver","stopBelowFoldObserver","translatePage","pageStart","scanStart","scanDuration","viewportHeight","viewportNodes","belowFoldWithPos","belowFoldNodes","item","glossaryStart","glossaryDuration","viewportBatches","createBatches","totalBatches","hasBelowFold","totalIpcTime","totalDomUpdateTime","firstTranslation","BATCH_CONCURRENCY","chunk","j","firstNode","IMMEDIATE_BELOW_FOLD","immediateNodes","deferredNodes","immediateBatches","setupScrollAwareTranslation","totalTime","deferredMsg","queued","translateDynamicContent","batches","batchNodes","rawTexts","n","processedTexts","restoreFns","chunkSize","chunks","translatedChunks","entries","chunkIndex","validNodes","undoTranslation","imageOverlayCount","imageTranslationOverlays","clearImageOverlays","translatedElements","restoredCount","textNode","MUTATION_BATCH_CAP","processPendingMutations","addedNodes","mutation","processNextChunk","startMutationObserver","mutations","createImageOverlay","img","translatedBlocks","overlay","scaleX","scaleY","block","blockEl","blockWidth","blockHeight","fontSize","findImageByUrl","url","images","imageUrlToDataUrl","imageUrl","canvas","ctx","blob","resolve","reject","reader","tempImg","translateImage","imageData","ocrResult","errorMessage","removeTooltip","_sender","sendResponse","enabled","visible","checkAutoTranslate","siteSpecificRules","shouldAutoTranslate","startTranslation"],"mappings":"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"}